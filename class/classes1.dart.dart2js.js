// Generated by dart2js (fast startup emitter, strong), the Dart to JavaScript compiler.
// The code supports the following hooks:
// dartPrint(message):
//    if this function is defined it is called instead of the Dart [print]
//    method.
//
// dartMainRunner(main, args):
//    if this function is defined, the Dart [main] method will not be invoked
//    directly. Instead, a closure that will invoke [main], and its arguments
//    [args] is passed to [dartMainRunner].
//
// dartDeferredLibraryLoader(uri, successCallback, errorCallback):
//    if this function is defined, it will be called when a deferred library
//    is loaded. It should load and eval the javascript of `uri`, and call
//    successCallback. If it fails to do so, it should call errorCallback with
//    an error.
//
// dartCallInstrumentation(id, qualifiedName):
//    if this function is defined, it will be called at each entry of a
//    method or constructor. Used only when compiling programs with
//    --experiment-call-instrumentation.
(function dartProgram() {
  function copyProperties(from, to) {
    var keys = Object.keys(from);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      to[key] = from[key];
    }
  }
  var supportsDirectProtoAccess = function() {
    var cls = function() {
    };
    cls.prototype = {p: {}};
    var object = new cls();
    if (!(object.__proto__ && object.__proto__.p === cls.prototype.p))
      return false;
    try {
      if (typeof navigator != "undefined" && typeof navigator.userAgent == "string" && navigator.userAgent.indexOf("Chrome/") >= 0)
        return true;
      if (typeof version == "function" && version.length == 0) {
        var v = version();
        if (/^\d+\.\d+\.\d+\.\d+$/.test(v))
          return true;
      }
    } catch (_) {
    }
    return false;
  }();
  function setFunctionNamesIfNecessary(holders) {
    function t() {
    }
    ;
    if (typeof t.name == "string")
      return;
    for (var i = 0; i < holders.length; i++) {
      var holder = holders[i];
      var keys = Object.keys(holder);
      for (var j = 0; j < keys.length; j++) {
        var key = keys[j];
        var f = holder[key];
        if (typeof f == 'function')
          f.name = key;
      }
    }
  }
  function inherit(cls, sup) {
    cls.prototype.constructor = cls;
    cls.prototype["$is" + cls.name] = cls;
    if (sup != null) {
      if (supportsDirectProtoAccess) {
        cls.prototype.__proto__ = sup.prototype;
        return;
      }
      var clsPrototype = Object.create(sup.prototype);
      copyProperties(cls.prototype, clsPrototype);
      cls.prototype = clsPrototype;
    }
  }
  function inheritMany(sup, classes) {
    for (var i = 0; i < classes.length; i++)
      inherit(classes[i], sup);
  }
  function mixin(cls, mixin) {
    copyProperties(mixin.prototype, cls.prototype);
    cls.prototype.constructor = cls;
  }
  function lazy(holder, name, getterName, initializer) {
    var uninitializedSentinel = holder;
    holder[name] = uninitializedSentinel;
    holder[getterName] = function() {
      holder[getterName] = function() {
        H.throwCyclicInit(name);
      };
      var result;
      var sentinelInProgress = initializer;
      try {
        if (holder[name] === uninitializedSentinel) {
          result = holder[name] = sentinelInProgress;
          result = holder[name] = initializer();
        } else
          result = holder[name];
      } finally {
        if (result === sentinelInProgress)
          holder[name] = null;
        holder[getterName] = function() {
          return this[name];
        };
      }
      return result;
    };
  }
  function makeConstList(list) {
    list.immutable$list = Array;
    list.fixed$length = Array;
    return list;
  }
  function convertToFastObject(properties) {
    function t() {
    }
    t.prototype = properties;
    new t();
    return properties;
  }
  function convertAllToFastObject(arrayOfObjects) {
    for (var i = 0; i < arrayOfObjects.length; ++i)
      convertToFastObject(arrayOfObjects[i]);
  }
  var functionCounter = 0;
  function tearOffGetter(funcs, applyTrampolineIndex, reflectionInfo, name, isIntercepted) {
    return isIntercepted ? new Function("funcs", "applyTrampolineIndex", "reflectionInfo", "name", "H", "c", "return function tearOff_" + name + functionCounter++ + "(receiver) {" + "if (c === null) c = " + "H.closureFromTearOff" + "(" + "this, funcs, applyTrampolineIndex, reflectionInfo, false, true, name);" + "return new c(this, funcs[0], receiver, name);" + "}")(funcs, applyTrampolineIndex, reflectionInfo, name, H, null) : new Function("funcs", "applyTrampolineIndex", "reflectionInfo", "name", "H", "c", "return function tearOff_" + name + functionCounter++ + "() {" + "if (c === null) c = " + "H.closureFromTearOff" + "(" + "this, funcs, applyTrampolineIndex, reflectionInfo, false, false, name);" + "return new c(this, funcs[0], null, name);" + "}")(funcs, applyTrampolineIndex, reflectionInfo, name, H, null);
  }
  function tearOff(funcs, applyTrampolineIndex, reflectionInfo, isStatic, name, isIntercepted) {
    var cache = null;
    return isStatic ? function() {
      if (cache === null)
        cache = H.closureFromTearOff(this, funcs, applyTrampolineIndex, reflectionInfo, true, false, name).prototype;
      return cache;
    } : tearOffGetter(funcs, applyTrampolineIndex, reflectionInfo, name, isIntercepted);
  }
  var typesOffset = 0;
  function installTearOff(container, getterName, isStatic, isIntercepted, requiredParameterCount, optionalParameterDefaultValues, callNames, funsOrNames, funType, applyIndex) {
    var funs = [];
    for (var i = 0; i < funsOrNames.length; i++) {
      var fun = funsOrNames[i];
      if (typeof fun == 'string')
        fun = container[fun];
      fun.$callName = callNames[i];
      funs.push(fun);
    }
    var fun = funs[0];
    fun.$requiredArgCount = requiredParameterCount;
    fun.$defaultValues = optionalParameterDefaultValues;
    var reflectionInfo = funType;
    if (typeof reflectionInfo == "number")
      reflectionInfo += typesOffset;
    var name = funsOrNames[0];
    fun.$stubName = name;
    var getterFunction = tearOff(funs, applyIndex || 0, reflectionInfo, isStatic, name, isIntercepted);
    container[getterName] = getterFunction;
    if (isStatic)
      fun.$tearOff = getterFunction;
  }
  function installStaticTearOff(container, getterName, requiredParameterCount, optionalParameterDefaultValues, callNames, funsOrNames, funType, applyIndex) {
    return installTearOff(container, getterName, true, false, requiredParameterCount, optionalParameterDefaultValues, callNames, funsOrNames, funType, applyIndex);
  }
  function installInstanceTearOff(container, getterName, isIntercepted, requiredParameterCount, optionalParameterDefaultValues, callNames, funsOrNames, funType, applyIndex) {
    return installTearOff(container, getterName, false, isIntercepted, requiredParameterCount, optionalParameterDefaultValues, callNames, funsOrNames, funType, applyIndex);
  }
  function setOrUpdateInterceptorsByTag(newTags) {
    var tags = init.interceptorsByTag;
    if (!tags) {
      init.interceptorsByTag = newTags;
      return;
    }
    copyProperties(newTags, tags);
  }
  function setOrUpdateLeafTags(newTags) {
    var tags = init.leafTags;
    if (!tags) {
      init.leafTags = newTags;
      return;
    }
    copyProperties(newTags, tags);
  }
  function updateTypes(newTypes) {
    var types = init.types;
    var length = types.length;
    types.push.apply(types, newTypes);
    return length;
  }
  function updateHolder(holder, newHolder) {
    copyProperties(newHolder, holder);
    return holder;
  }
  var hunkHelpers = function() {
    var mkInstance = function(isIntercepted, requiredParameterCount, optionalParameterDefaultValues, callNames, applyIndex) {
        return function(container, getterName, name, funType) {
          return installInstanceTearOff(container, getterName, isIntercepted, requiredParameterCount, optionalParameterDefaultValues, callNames, [name], funType, applyIndex);
        };
      },
      mkStatic = function(requiredParameterCount, optionalParameterDefaultValues, callNames, applyIndex) {
        return function(container, getterName, name, funType) {
          return installStaticTearOff(container, getterName, requiredParameterCount, optionalParameterDefaultValues, callNames, [name], funType, applyIndex);
        };
      };
    return {inherit: inherit, inheritMany: inheritMany, mixin: mixin, installStaticTearOff: installStaticTearOff, installInstanceTearOff: installInstanceTearOff, _instance_0u: mkInstance(0, 0, null, ["call$0"], 0), _instance_1u: mkInstance(0, 1, null, ["call$1"], 0), _instance_2u: mkInstance(0, 2, null, ["call$2"], 0), _instance_0i: mkInstance(1, 0, null, ["call$0"], 0), _instance_1i: mkInstance(1, 1, null, ["call$1"], 0), _instance_2i: mkInstance(1, 2, null, ["call$2"], 0), _static_0: mkStatic(0, null, ["call$0"], 0), _static_1: mkStatic(1, null, ["call$1"], 0), _static_2: mkStatic(2, null, ["call$2"], 0), makeConstList: makeConstList, lazy: lazy, updateHolder: updateHolder, convertToFastObject: convertToFastObject, setFunctionNamesIfNecessary: setFunctionNamesIfNecessary, updateTypes: updateTypes, setOrUpdateInterceptorsByTag: setOrUpdateInterceptorsByTag, setOrUpdateLeafTags: setOrUpdateLeafTags};
  }();
  function initializeDeferredHunk(hunk) {
    typesOffset = init.types.length;
    hunk(hunkHelpers, init, holders, $);
  }
  function getGlobalFromName(name) {
    for (var i = 0; i < holders.length; i++) {
      if (holders[i] == C)
        continue;
      if (holders[i][name])
        return holders[i][name];
    }
  }
  var C = {},
  H = {JS_CONST: function JS_CONST() {
    },
    unminifyOrTag: function(rawClassName) {
      var preserved = H.unmangleGlobalNameIfPreservedAnyways(rawClassName);
      if (preserved != null)
        return preserved;
      return rawClassName;
    },
    S: function(value) {
      var res;
      if (typeof value == "string")
        return value;
      if (typeof value == "number") {
        if (value !== 0)
          return "" + value;
      } else if (true === value)
        return "true";
      else if (false === value)
        return "false";
      else if (value == null)
        return "null";
      res = J.toString$0$(value);
      return res;
    },
    Primitives_objectTypeName: function(object) {
      return H.Primitives__objectTypeNameNewRti(object);
    },
    Primitives__objectTypeNameNewRti: function(object) {
      var dispatchName, $constructor, constructorName;
      if (object instanceof P.Object)
        return H.instanceTypeName(object);
      if (J.getInterceptor$(object) === C.Interceptor_methods || false) {
        dispatchName = H.constructorNameFallback(object);
        if (H.Primitives__saneNativeClassName(dispatchName))
          return dispatchName;
        $constructor = object.constructor;
        if (typeof $constructor == "function") {
          constructorName = $constructor.name;
          if (typeof constructorName == "string" && H.Primitives__saneNativeClassName(constructorName))
            return constructorName;
        }
      }
      return H.instanceTypeName(object);
    },
    Primitives__saneNativeClassName: function($name) {
      var t1 = $name !== "Object" && $name !== "";
      return t1;
    },
    Primitives_objectToHumanReadableString: function(object) {
      return "Instance of '" + H.Primitives_objectTypeName(object) + "'";
    },
    Primitives_stringConcatUnchecked: function(string1, string2) {
      return string1 + string2;
    },
    Primitives_flattenString: function(str) {
      return str.charCodeAt(0) == 0 ? str : str;
    },
    JsCache_fetch: function(cache, key) {
      return cache[key];
    },
    ioore: function(receiver, index) {
      if (receiver == null)
        J.get$length$as(receiver);
      throw H.wrapException(H.diagnoseIndexError(receiver, index));
    },
    diagnoseIndexError: function(indexable, index) {
      var $length, _s5_ = "index";
      if (!H._isInt(index))
        return P.ArgumentError$value(index, _s5_, null);
      $length = J.get$length$as(indexable);
      if (index < 0 || index >= $length)
        return P.IndexError$(index, indexable, _s5_, null, $length);
      return P.RangeError$value(index, _s5_);
    },
    wrapException: function(ex) {
      var wrapper, t1;
      if (ex == null)
        ex = P.NullThrownError$();
      wrapper = new Error();
      wrapper.dartException = ex;
      t1 = H.toStringWrapper;
      if ("defineProperty" in Object) {
        Object.defineProperty(wrapper, "message", {get: t1});
        wrapper.name = "";
      } else
        wrapper.toString = t1;
      return wrapper;
    },
    toStringWrapper: function() {
      return J.toString$0$(this.dartException);
    },
    throwConcurrentModificationError: function(collection) {
      throw H.wrapException(P.ConcurrentModificationError$(collection));
    },
    Closure_fromTearOff: function(receiver, functions, applyTrampolineIndex, reflectionInfo, isStatic, isIntercepted, propertyName) {
      var $constructor, t1, trampoline, applyTrampoline, i, stub, stubCallName,
        $function = functions[0],
        callName = $function.$callName,
        $prototype = isStatic ? Object.create(H.StaticClosure$().constructor.prototype) : Object.create(H.BoundClosure$(null, null, null, "").constructor.prototype);
      $prototype.$initialize = $prototype.constructor;
      if (isStatic)
        $constructor = function static_tear_off() {
          this.$initialize();
        };
      else if (H.boolConversionCheck(H.Closure_isCsp())) {
        t1 = function tear_off(a, b, c, d) {
          this.$initialize(a, b, c, d);
        };
        $constructor = t1;
      } else {
        t1 = $.Closure_functionCounter;
        if (typeof t1 !== "number")
          return t1.$add();
        $.Closure_functionCounter = t1 + 1;
        t1 = new Function("a,b,c,d" + t1, "this.$initialize(a,b,c,d" + t1 + ")");
        $constructor = t1;
      }
      $prototype.constructor = $constructor;
      $constructor.prototype = $prototype;
      if (!isStatic) {
        trampoline = H.Closure_forwardCallTo(receiver, $function, isIntercepted);
        trampoline.$reflectionInfo = reflectionInfo;
      } else {
        $prototype.$static_name = propertyName;
        trampoline = $function;
      }
      type$.Object._as(reflectionInfo);
      $prototype.$signature = H.Closure__computeSignatureFunctionNewRti(reflectionInfo, isStatic, isIntercepted);
      $prototype[callName] = trampoline;
      for (applyTrampoline = trampoline, i = 1; i < functions.length; ++i) {
        stub = functions[i];
        stubCallName = stub.$callName;
        if (stubCallName != null) {
          stub = isStatic ? stub : H.Closure_forwardCallTo(receiver, stub, isIntercepted);
          $prototype[stubCallName] = stub;
        }
        if (i === applyTrampolineIndex) {
          stub.$reflectionInfo = reflectionInfo;
          applyTrampoline = stub;
        }
      }
      $prototype["call*"] = applyTrampoline;
      $prototype.$requiredArgCount = $function.$requiredArgCount;
      $prototype.$defaultValues = $function.$defaultValues;
      return $constructor;
    },
    Closure__computeSignatureFunctionNewRti: function(functionType, isStatic, isIntercepted) {
      var typeEvalMethod;
      if (typeof functionType == "number")
        return function(getType, t) {
          return function() {
            return getType(t);
          };
        }(H.getTypeFromTypesTable, functionType);
      if (typeof functionType == "string") {
        if (isStatic)
          throw H.wrapException("Cannot compute signature for static tearoff.");
        typeEvalMethod = isIntercepted ? H.BoundClosure_evalRecipeIntercepted : H.BoundClosure_evalRecipe;
        return function(recipe, evalOnReceiver) {
          return function() {
            return evalOnReceiver(this, recipe);
          };
        }(functionType, typeEvalMethod);
      }
      throw H.wrapException("Error in functionType of tearoff");
    },
    Closure_cspForwardCall: function(arity, isSuperCall, stubName, $function) {
      var getSelf = H.BoundClosure_selfOf;
      switch (isSuperCall ? -1 : arity) {
        case 0:
          return function(n, S) {
            return function() {
              return S(this)[n]();
            };
          }(stubName, getSelf);
        case 1:
          return function(n, S) {
            return function(a) {
              return S(this)[n](a);
            };
          }(stubName, getSelf);
        case 2:
          return function(n, S) {
            return function(a, b) {
              return S(this)[n](a, b);
            };
          }(stubName, getSelf);
        case 3:
          return function(n, S) {
            return function(a, b, c) {
              return S(this)[n](a, b, c);
            };
          }(stubName, getSelf);
        case 4:
          return function(n, S) {
            return function(a, b, c, d) {
              return S(this)[n](a, b, c, d);
            };
          }(stubName, getSelf);
        case 5:
          return function(n, S) {
            return function(a, b, c, d, e) {
              return S(this)[n](a, b, c, d, e);
            };
          }(stubName, getSelf);
        default:
          return function(f, s) {
            return function() {
              return f.apply(s(this), arguments);
            };
          }($function, getSelf);
      }
    },
    Closure_isCsp: function() {
      return false;
    },
    Closure_forwardCallTo: function(receiver, $function, isIntercepted) {
      var stubName, arity, lookedUpFunction, t1, selfName, $arguments;
      if (isIntercepted)
        return H.Closure_forwardInterceptedCallTo(receiver, $function);
      stubName = $function.$stubName;
      arity = $function.length;
      lookedUpFunction = receiver[stubName];
      t1 = $function == null ? lookedUpFunction == null : $function === lookedUpFunction;
      if (H.boolConversionCheck(H.Closure_isCsp()) || !t1 || arity >= 27)
        return H.Closure_cspForwardCall(arity, !t1, stubName, $function);
      if (arity === 0) {
        t1 = $.Closure_functionCounter;
        if (typeof t1 !== "number")
          return t1.$add();
        $.Closure_functionCounter = t1 + 1;
        selfName = "self" + t1;
        return new Function("return function(){var " + selfName + " = this." + H.S(H.BoundClosure_selfFieldName()) + ";return " + selfName + "." + H.S(stubName) + "();}")();
      }
      H.assertHelper(1 <= arity && arity < 27);
      $arguments = "abcdefghijklmnopqrstuvwxyz".split("").splice(0, arity).join(",");
      t1 = $.Closure_functionCounter;
      if (typeof t1 !== "number")
        return t1.$add();
      $.Closure_functionCounter = t1 + 1;
      $arguments += t1;
      return new Function("return function(" + $arguments + "){return this." + H.S(H.BoundClosure_selfFieldName()) + "." + H.S(stubName) + "(" + $arguments + ");}")();
    },
    Closure_cspForwardInterceptedCall: function(arity, isSuperCall, $name, $function) {
      var getSelf = H.BoundClosure_selfOf,
        getReceiver = H.BoundClosure_receiverOf;
      switch (isSuperCall ? -1 : arity) {
        case 0:
          throw H.wrapException(H.RuntimeError$("Intercepted function with no arguments."));
        case 1:
          return function(n, s, r) {
            return function() {
              return s(this)[n](r(this));
            };
          }($name, getSelf, getReceiver);
        case 2:
          return function(n, s, r) {
            return function(a) {
              return s(this)[n](r(this), a);
            };
          }($name, getSelf, getReceiver);
        case 3:
          return function(n, s, r) {
            return function(a, b) {
              return s(this)[n](r(this), a, b);
            };
          }($name, getSelf, getReceiver);
        case 4:
          return function(n, s, r) {
            return function(a, b, c) {
              return s(this)[n](r(this), a, b, c);
            };
          }($name, getSelf, getReceiver);
        case 5:
          return function(n, s, r) {
            return function(a, b, c, d) {
              return s(this)[n](r(this), a, b, c, d);
            };
          }($name, getSelf, getReceiver);
        case 6:
          return function(n, s, r) {
            return function(a, b, c, d, e) {
              return s(this)[n](r(this), a, b, c, d, e);
            };
          }($name, getSelf, getReceiver);
        default:
          return function(f, s, r, a) {
            return function() {
              a = [r(this)];
              Array.prototype.push.apply(a, arguments);
              return f.apply(s(this), a);
            };
          }($function, getSelf, getReceiver);
      }
    },
    Closure_forwardInterceptedCallTo: function(receiver, $function) {
      var $arguments,
        selfField = H.BoundClosure_selfFieldName(),
        receiverField = H.BoundClosure_receiverFieldName(),
        stubName = $function.$stubName,
        arity = $function.length,
        lookedUpFunction = receiver[stubName],
        t1 = $function == null ? lookedUpFunction == null : $function === lookedUpFunction,
        t2 = !t1 || arity >= 28;
      if (t2)
        return H.Closure_cspForwardInterceptedCall(arity, !t1, stubName, $function);
      if (arity === 1) {
        t1 = "return function(){return this." + selfField + "." + H.S(stubName) + "(this." + receiverField + ");";
        t2 = $.Closure_functionCounter;
        if (typeof t2 !== "number")
          return t2.$add();
        $.Closure_functionCounter = t2 + 1;
        return new Function(t1 + t2 + "}")();
      }
      H.assertHelper(1 < arity && arity < 28);
      $arguments = "abcdefghijklmnopqrstuvwxyz".split("").splice(0, arity - 1).join(",");
      t1 = "return function(" + $arguments + "){return this." + selfField + "." + H.S(stubName) + "(this." + receiverField + ", " + $arguments + ");";
      t2 = $.Closure_functionCounter;
      if (typeof t2 !== "number")
        return t2.$add();
      $.Closure_functionCounter = t2 + 1;
      return new Function(t1 + t2 + "}")();
    },
    closureFromTearOff: function(receiver, functions, applyTrampolineIndex, reflectionInfo, isStatic, isIntercepted, $name) {
      return H.Closure_fromTearOff(receiver, functions, applyTrampolineIndex, reflectionInfo, !!isStatic, !!isIntercepted, $name);
    },
    StaticClosure$: function() {
      return new H.StaticClosure();
    },
    BoundClosure$: function(_self, _target, _receiver, _name) {
      return new H.BoundClosure(_self, _target, _receiver, _name);
    },
    BoundClosure_evalRecipe: function(closure, recipe) {
      return H.evalInInstance(closure._self, recipe);
    },
    BoundClosure_evalRecipeIntercepted: function(closure, recipe) {
      return H.evalInInstance(closure._receiver, recipe);
    },
    BoundClosure_selfOf: function(closure) {
      return closure._self;
    },
    BoundClosure_receiverOf: function(closure) {
      return closure._receiver;
    },
    BoundClosure_selfFieldName: function() {
      var t1 = $.BoundClosure_selfFieldNameCache;
      return t1 == null ? $.BoundClosure_selfFieldNameCache = H.BoundClosure_computeFieldNamed("self") : t1;
    },
    BoundClosure_receiverFieldName: function() {
      var t1 = $.BoundClosure_receiverFieldNameCache;
      return t1 == null ? $.BoundClosure_receiverFieldNameCache = H.BoundClosure_computeFieldNamed("receiver") : t1;
    },
    BoundClosure_computeFieldNamed: function(fieldName) {
      var t1, i, $name,
        template = H.BoundClosure$("self", "target", "receiver", "name"),
        names = J.JSArray_markFixedList(Object.getOwnPropertyNames(template), type$.dynamic);
      for (t1 = names.length, i = 0; i < t1; ++i) {
        $name = names[i];
        if (template[$name] === fieldName)
          return $name;
      }
      throw H.wrapException(P.ArgumentError$("Field name " + fieldName + " not found."));
    },
    boolConversionCheck: function(value) {
      if (value == null)
        H.assertThrow("boolean expression must not be null");
      return value;
    },
    assertTest: function(condition) {
      if (true === condition)
        return false;
      if (false === condition)
        return true;
      H._asBool(condition);
      return !condition;
    },
    assertThrow: function(message) {
      throw H.wrapException(H._AssertionError$(message));
    },
    assertHelper: function(condition) {
      if (H.assertTest(condition))
        throw H.wrapException(P.AssertionError$(null));
    },
    throwCyclicInit: function(staticName) {
      throw H.wrapException(P.CyclicInitializationError$(staticName));
    },
    RuntimeError$: function(message) {
      return new H.RuntimeError(message);
    },
    jsonEncodeNative: function(string) {
      return JSON.stringify(string);
    },
    _AssertionError$: function(message) {
      return new H._AssertionError(message);
    },
    constructorNameFallback: function(object) {
      return C.C_JS_CONST(object);
    },
    Closure: function Closure() {
    },
    TearOffClosure: function TearOffClosure() {
    },
    StaticClosure: function StaticClosure() {
    },
    BoundClosure: function BoundClosure(t0, t1, t2, t3) {
      var _ = this;
      _._self = t0;
      _._target = t1;
      _._receiver = t2;
      _._name = t3;
    },
    RuntimeError: function RuntimeError(t0) {
      this.message = t0;
    },
    _AssertionError: function _AssertionError(t0) {
      this.message = t0;
    },
    Rti$: function() {
      return new H.Rti(null, null);
    },
    Rti__setAsCheckFunction: function(rti, fn) {
      rti._as = fn;
    },
    Rti__setIsTestFunction: function(rti, fn) {
      rti._is = fn;
    },
    Rti__asCheck: function(rti, object) {
      return rti._as(object);
    },
    Rti__isCheck: function(rti, object) {
      return rti._is(object);
    },
    Rti__getPrecomputed1: function(rti) {
      return rti._precomputed1;
    },
    Rti__setPrecomputed1: function(rti, precomputed) {
      rti._precomputed1 = precomputed;
    },
    Rti__getQuestionFromStar: function(universe, rti) {
      var question;
      H.assertHelper(H.Rti__getKind(rti) === 6);
      question = H._Utils_asRtiOrNull(H.Rti__getPrecomputed1(rti));
      if (question == null) {
        question = H._Universe__lookupQuestionRti(universe, H.Rti__getStarArgument(rti), true);
        H.Rti__setPrecomputed1(rti, question);
      }
      return question;
    },
    Rti__getFutureFromFutureOr: function(universe, rti) {
      var future;
      H.assertHelper(H.Rti__getKind(rti) === 8);
      future = H._Utils_asRtiOrNull(H.Rti__getPrecomputed1(rti));
      if (future == null) {
        future = H._Universe__lookupFutureRti(universe, H.Rti__getFutureOrArgument(rti));
        H.Rti__setPrecomputed1(rti, future);
      }
      return future;
    },
    Rti__getSpecializedTestResource: function(rti) {
      return rti._specializedTestResource;
    },
    Rti__setSpecializedTestResource: function(rti, value) {
      rti._specializedTestResource = value;
    },
    Rti__getKind: function(rti) {
      return H._Utils_asInt(rti._kind);
    },
    Rti__setKind: function(rti, kind) {
      rti._kind = kind;
    },
    Rti__isUnionOfFunctionType: function(rti) {
      var kind = H.Rti__getKind(rti);
      if (kind === 6 || kind === 7 || kind === 8)
        return H.Rti__isUnionOfFunctionType(H._Utils_asRti(H.Rti__getPrimary(rti)));
      return kind === 11 || kind === 12;
    },
    Rti__getPrimary: function(rti) {
      return rti._primary;
    },
    Rti__setPrimary: function(rti, value) {
      rti._primary = value;
    },
    Rti__getRest: function(rti) {
      return rti._rest;
    },
    Rti__setRest: function(rti, value) {
      rti._rest = value;
    },
    Rti__getInterfaceName: function(rti) {
      H.assertHelper(H.Rti__getKind(rti) === 9);
      return H._Utils_asString(H.Rti__getPrimary(rti));
    },
    Rti__getInterfaceTypeArguments: function(rti) {
      H.assertHelper(H.Rti__getKind(rti) === 9);
      return H.Rti__getRest(rti);
    },
    Rti__getBindingBase: function(rti) {
      H.assertHelper(H.Rti__getKind(rti) === 10);
      return H._Utils_asRti(H.Rti__getPrimary(rti));
    },
    Rti__getBindingArguments: function(rti) {
      H.assertHelper(H.Rti__getKind(rti) === 10);
      return H.Rti__getRest(rti);
    },
    Rti__getStarArgument: function(rti) {
      H.assertHelper(H.Rti__getKind(rti) === 6);
      return H._Utils_asRti(H.Rti__getPrimary(rti));
    },
    Rti__getQuestionArgument: function(rti) {
      H.assertHelper(H.Rti__getKind(rti) === 7);
      return H._Utils_asRti(H.Rti__getPrimary(rti));
    },
    Rti__getFutureOrArgument: function(rti) {
      H.assertHelper(H.Rti__getKind(rti) === 8);
      return H._Utils_asRti(H.Rti__getPrimary(rti));
    },
    Rti__getReturnType: function(rti) {
      H.assertHelper(H.Rti__getKind(rti) === 11);
      return H._Utils_asRti(H.Rti__getPrimary(rti));
    },
    Rti__getFunctionParameters: function(rti) {
      H.assertHelper(H.Rti__getKind(rti) === 11);
      return H.Rti__getRest(rti);
    },
    Rti__getGenericFunctionBase: function(rti) {
      H.assertHelper(H.Rti__getKind(rti) === 12);
      return H._Utils_asRti(H.Rti__getPrimary(rti));
    },
    Rti__getGenericFunctionBounds: function(rti) {
      H.assertHelper(H.Rti__getKind(rti) === 12);
      return H.Rti__getRest(rti);
    },
    Rti__getGenericFunctionParameterIndex: function(rti) {
      H.assertHelper(H.Rti__getKind(rti) === 13);
      return H._Utils_asInt(H.Rti__getPrimary(rti));
    },
    Rti__getEvalCache: function(rti) {
      return rti._evalCache;
    },
    Rti__setEvalCache: function(rti, value) {
      rti._evalCache = value;
    },
    Rti__getBindCache: function(rti) {
      return rti._bindCache;
    },
    Rti__setBindCache: function(rti, value) {
      rti._bindCache = value;
    },
    Rti_allocate: function() {
      return H.Rti$();
    },
    Rti__getCanonicalRecipe: function(rti) {
      var s = rti._canonicalRecipe;
      if (H.assertTest(H._Utils_isString(s)))
        H.assertThrow("Missing canonical recipe");
      return H._Utils_asString(s);
    },
    Rti__setCanonicalRecipe: function(rti, s) {
      rti._canonicalRecipe = s;
    },
    _FunctionParameters$: function() {
      return new H._FunctionParameters();
    },
    _FunctionParameters_allocate: function() {
      return H._FunctionParameters$();
    },
    _FunctionParameters__getRequiredPositional: function(parameters) {
      return parameters._requiredPositional;
    },
    _FunctionParameters__setRequiredPositional: function(parameters, requiredPositional) {
      parameters._requiredPositional = requiredPositional;
    },
    _FunctionParameters__getOptionalPositional: function(parameters) {
      return parameters._optionalPositional;
    },
    _FunctionParameters__setOptionalPositional: function(parameters, optionalPositional) {
      parameters._optionalPositional = optionalPositional;
    },
    _FunctionParameters__getNamed: function(parameters) {
      return parameters._named;
    },
    _FunctionParameters__setNamed: function(parameters, named) {
      parameters._named = named;
    },
    _theUniverse: function() {
      return init.typeUniverse;
    },
    _rtiEval: function(environment, recipe) {
      return H._Universe_evalInEnvironment(H._theUniverse(), environment, recipe);
    },
    _rtiBind: function(environment, types) {
      return H._Universe_bind(H._theUniverse(), environment, types);
    },
    findType: function(recipe) {
      return H._Universe_eval(H._theUniverse(), recipe, false);
    },
    evalInInstance: function(instance, recipe) {
      return H._rtiEval(H.instanceType(instance), recipe);
    },
    _substitute: function(universe, rti, typeArguments, depth) {
      var baseType, substitutedBaseType, interfaceTypeArguments, substitutedInterfaceTypeArguments, base, substitutedBase, $arguments, substitutedArguments, returnType, substitutedReturnType, functionParameters, substitutedFunctionParameters, bounds, substitutedBounds, index, argument,
        kind = H.Rti__getKind(rti);
      switch (kind) {
        case 5:
        case 1:
        case 2:
        case 3:
        case 4:
          return rti;
        case 6:
          baseType = H._Utils_asRti(H.Rti__getPrimary(rti));
          substitutedBaseType = H._substitute(universe, baseType, typeArguments, depth);
          if (H._Utils_isIdentical(substitutedBaseType, baseType))
            return rti;
          return H._Universe__lookupStarRti(universe, substitutedBaseType, true);
        case 7:
          baseType = H._Utils_asRti(H.Rti__getPrimary(rti));
          substitutedBaseType = H._substitute(universe, baseType, typeArguments, depth);
          if (H._Utils_isIdentical(substitutedBaseType, baseType))
            return rti;
          return H._Universe__lookupQuestionRti(universe, substitutedBaseType, true);
        case 8:
          baseType = H._Utils_asRti(H.Rti__getPrimary(rti));
          substitutedBaseType = H._substitute(universe, baseType, typeArguments, depth);
          if (H._Utils_isIdentical(substitutedBaseType, baseType))
            return rti;
          return H._Universe__lookupFutureOrRti(universe, substitutedBaseType, true);
        case 9:
          interfaceTypeArguments = H.Rti__getInterfaceTypeArguments(rti);
          substitutedInterfaceTypeArguments = H._substituteArray(universe, interfaceTypeArguments, typeArguments, depth);
          if (H._Utils_isIdentical(substitutedInterfaceTypeArguments, interfaceTypeArguments))
            return rti;
          return H._Universe__lookupInterfaceRti(universe, H.Rti__getInterfaceName(rti), substitutedInterfaceTypeArguments);
        case 10:
          base = H.Rti__getBindingBase(rti);
          substitutedBase = H._substitute(universe, base, typeArguments, depth);
          $arguments = H.Rti__getBindingArguments(rti);
          substitutedArguments = H._substituteArray(universe, $arguments, typeArguments, depth);
          if (H._Utils_isIdentical(substitutedBase, base) && H._Utils_isIdentical(substitutedArguments, $arguments))
            return rti;
          return H._Universe__lookupBindingRti(universe, substitutedBase, substitutedArguments);
        case 11:
          returnType = H.Rti__getReturnType(rti);
          substitutedReturnType = H._substitute(universe, returnType, typeArguments, depth);
          functionParameters = H.Rti__getFunctionParameters(rti);
          substitutedFunctionParameters = H._substituteFunctionParameters(universe, functionParameters, typeArguments, depth);
          if (H._Utils_isIdentical(substitutedReturnType, returnType) && H._Utils_isIdentical(substitutedFunctionParameters, functionParameters))
            return rti;
          return H._Universe__lookupFunctionRti(universe, substitutedReturnType, substitutedFunctionParameters);
        case 12:
          bounds = H.Rti__getGenericFunctionBounds(rti);
          depth += H._Utils_arrayLength(bounds);
          substitutedBounds = H._substituteArray(universe, bounds, typeArguments, depth);
          base = H.Rti__getGenericFunctionBase(rti);
          substitutedBase = H._substitute(universe, base, typeArguments, depth);
          if (H._Utils_isIdentical(substitutedBounds, bounds) && H._Utils_isIdentical(substitutedBase, base))
            return rti;
          return H._Universe__lookupGenericFunctionRti(universe, substitutedBase, substitutedBounds, true);
        case 13:
          index = H.Rti__getGenericFunctionParameterIndex(rti);
          if (index < depth)
            return rti;
          argument = H._Utils_arrayAt(typeArguments, index - depth);
          if (argument == null)
            return rti;
          return H._Utils_asRti(argument);
        default:
          throw H.wrapException(P.AssertionError$("Attempted to substitute unexpected RTI kind " + kind));
      }
    },
    _substituteArray: function(universe, rtiArray, typeArguments, depth) {
      var changed, i, rti, substitutedRti,
        $length = H._Utils_arrayLength(rtiArray),
        result = [];
      for (changed = false, i = 0; i < $length; ++i) {
        rti = H._Utils_asRti(H._Utils_arrayAt(rtiArray, i));
        substitutedRti = H._substitute(universe, rti, typeArguments, depth);
        if (H._Utils_isNotIdentical(substitutedRti, rti))
          changed = true;
        H._Utils_arrayPush(result, substitutedRti);
      }
      return changed ? result : rtiArray;
    },
    _substituteNamed: function(universe, namedArray, typeArguments, depth) {
      var result, changed, i, $name, isRequired, rti, substitutedRti,
        $length = H._Utils_arrayLength(namedArray);
      H.assertHelper(H._Utils_isMultipleOf($length, 3));
      result = [];
      for (changed = false, i = 0; i < $length; i += 3) {
        $name = H._Utils_asString(H._Utils_arrayAt(namedArray, i));
        isRequired = H._Utils_asBool(H._Utils_arrayAt(namedArray, i + 1));
        rti = H._Utils_asRti(H._Utils_arrayAt(namedArray, i + 2));
        substitutedRti = H._substitute(universe, rti, typeArguments, depth);
        if (H._Utils_isNotIdentical(substitutedRti, rti))
          changed = true;
        H._Utils_arrayPush(result, $name);
        H._Utils_arrayPush(result, isRequired);
        H._Utils_arrayPush(result, substitutedRti);
      }
      return changed ? result : namedArray;
    },
    _substituteFunctionParameters: function(universe, functionParameters, typeArguments, depth) {
      var result,
        requiredPositional = H._FunctionParameters__getRequiredPositional(functionParameters),
        substitutedRequiredPositional = H._substituteArray(universe, requiredPositional, typeArguments, depth),
        optionalPositional = H._FunctionParameters__getOptionalPositional(functionParameters),
        substitutedOptionalPositional = H._substituteArray(universe, optionalPositional, typeArguments, depth),
        named = H._FunctionParameters__getNamed(functionParameters),
        substitutedNamed = H._substituteNamed(universe, named, typeArguments, depth);
      if (H._Utils_isIdentical(substitutedRequiredPositional, requiredPositional) && H._Utils_isIdentical(substitutedOptionalPositional, optionalPositional) && H._Utils_isIdentical(substitutedNamed, named))
        return functionParameters;
      result = H._FunctionParameters_allocate();
      H._FunctionParameters__setRequiredPositional(result, substitutedRequiredPositional);
      H._FunctionParameters__setOptionalPositional(result, substitutedOptionalPositional);
      H._FunctionParameters__setNamed(result, substitutedNamed);
      return result;
    },
    _isDartObject: function(object) {
      return H._Utils_instanceOf(object, P.Object);
    },
    _isClosure: function(object) {
      return H._Utils_instanceOf(object, H.Closure);
    },
    setRuntimeTypeInfo: function(target, rti) {
      H.assertHelper(rti != null);
      target[init.arrayRti] = rti;
      return target;
    },
    closureFunctionType: function(closure) {
      var signature = closure.$signature;
      if (signature != null) {
        if (typeof signature == "number")
          return H.getTypeFromTypesTable(H._Utils_asInt(signature));
        return H._Utils_asRti(closure.$signature());
      }
      return null;
    },
    instanceOrFunctionType: function(object, testRti) {
      var rti;
      if (H.Rti__isUnionOfFunctionType(testRti))
        if (H._isClosure(object)) {
          rti = H.closureFunctionType(object);
          if (rti != null)
            return rti;
        }
      return H.instanceType(object);
    },
    instanceType: function(object) {
      if (H._isDartObject(object))
        return H._instanceType(object);
      if (H._Utils_isArray(object))
        return H._arrayInstanceType(object);
      return H._instanceTypeFromConstructor(J.getInterceptor$(object));
    },
    _arrayInstanceType: function(object) {
      var rti = object[init.arrayRti],
        defaultRti = type$.JSArray_dynamic;
      if (rti == null)
        return H._Utils_asRti(defaultRti);
      if (rti.constructor !== defaultRti.constructor)
        return H._Utils_asRti(defaultRti);
      return H._Utils_asRti(rti);
    },
    _instanceType: function(object) {
      var rti = object.$ti;
      return rti != null ? H._Utils_asRti(rti) : H._instanceTypeFromConstructor(object);
    },
    instanceTypeName: function(object) {
      return H._rtiToString(H.instanceType(object), null);
    },
    _instanceTypeFromConstructor: function(instance) {
      var $constructor = instance.constructor,
        probe = $constructor.$ccache;
      if (probe != null)
        return H._Utils_asRti(probe);
      return H._instanceTypeFromConstructorMiss(instance, $constructor);
    },
    _instanceTypeFromConstructorMiss: function(instance, $constructor) {
      var effectiveConstructor = H._isClosure(instance) ? instance.__proto__.__proto__.constructor : $constructor,
        rti = H._Universe_findErasedType(H._theUniverse(), effectiveConstructor.name);
      $constructor.$ccache = rti;
      return rti;
    },
    getTypeFromTypesTable: function(index) {
      var table, type, rti;
      H._asInt(index);
      table = init.types;
      type = H._Utils_arrayAt(table, index);
      if (H._Utils_isString(type)) {
        rti = H.findType(H._Utils_asString(type));
        H._Utils_arraySetAt(table, index, rti);
        return rti;
      }
      return H._Utils_asRti(type);
    },
    _installSpecializedIsTest: function(object) {
      var unstarred, isFn, $name,
        testRti = H._Utils_asRti(this);
      if (H.isObjectType(testRti))
        return H._finishIsFn(testRti, object, H._isObject);
      if (H.isTopType(testRti))
        return H._finishIsFn(testRti, object, H._isTop);
      unstarred = H.Rti__getKind(testRti) === 6 ? H.Rti__getStarArgument(testRti) : testRti;
      isFn = H._simpleSpecializedIsTest(unstarred);
      if (isFn != null)
        return H._finishIsFn(testRti, object, isFn);
      if (H.Rti__getKind(unstarred) === 9) {
        $name = H.Rti__getInterfaceName(unstarred);
        if (H.Rti__getInterfaceTypeArguments(unstarred).every(H.isTopType)) {
          H.Rti__setSpecializedTestResource(testRti, "$is" + $name);
          return H._finishIsFn(testRti, object, H._isTestViaProperty);
        }
      } else if (H.Rti__getKind(testRti) === 7)
        return H._finishIsFn(testRti, object, H._generalNullableIsTestImplementation);
      return H._finishIsFn(testRti, object, H._generalIsTestImplementation);
    },
    _finishIsFn: function(testRti, object, isFn) {
      H.Rti__setIsTestFunction(testRti, isFn);
      return H.Rti__isCheck(testRti, object);
    },
    _simpleSpecializedIsTest: function(testRti) {
      var isFn;
      if (H._Utils_isIdentical(testRti, type$.int))
        isFn = H._isInt;
      else if (H._Utils_isIdentical(testRti, type$.double) || H._Utils_isIdentical(testRti, type$.num))
        isFn = H._isNum;
      else if (H._Utils_isIdentical(testRti, type$.String))
        isFn = H._isString;
      else
        isFn = H._Utils_isIdentical(testRti, type$.bool) ? H._isBool : null;
      return isFn;
    },
    _installSpecializedAsCheck: function(object) {
      var t1,
        testRti = H._Utils_asRti(this),
        asFn = H._generalAsCheckImplementation;
      if (H.isTopType(testRti))
        asFn = H._asTop;
      else if (H.isObjectType(testRti))
        asFn = H._asObject;
      else {
        t1 = H.isNullable(testRti);
        if (t1)
          asFn = H._generalNullableAsCheckImplementation;
      }
      H.Rti__setAsCheckFunction(testRti, asFn);
      return H.Rti__asCheck(testRti, object);
    },
    _nullIs: function(testRti) {
      var kind = H.Rti__getKind(testRti);
      return H.isTopType(testRti) || H._Utils_isIdentical(testRti, type$.legacy_Never) || kind === 7 || H.isNullType(testRti);
    },
    _generalIsTestImplementation: function(object) {
      var objectRti,
        testRti = H._Utils_asRti(this);
      if (object == null)
        return H._nullIs(testRti);
      objectRti = H.instanceOrFunctionType(object, testRti);
      return H.isSubtype(H._theUniverse(), objectRti, testRti);
    },
    _generalNullableIsTestImplementation: function(object) {
      if (object == null)
        return true;
      return H.Rti__isCheck(H.Rti__getQuestionArgument(H._Utils_asRti(this)), object);
    },
    _isTestViaProperty: function(object) {
      var testRti = H._Utils_asRti(this),
        tag = H.Rti__getSpecializedTestResource(testRti);
      if (H._isDartObject(object))
        return !!object[tag];
      return !!J.getInterceptor$(object)[tag];
    },
    _generalAsCheckImplementation: function(object) {
      var t1,
        testRti = H._Utils_asRti(this);
      if (object == null) {
        t1 = H.isNullable(testRti);
        if (t1)
          return object;
      } else if (H.Rti__isCheck(testRti, object))
        return object;
      H._failedAsCheck(object, testRti);
    },
    _generalNullableAsCheckImplementation: function(object) {
      var testRti = H._Utils_asRti(this);
      if (object == null)
        return object;
      else if (H.Rti__isCheck(testRti, object))
        return object;
      H._failedAsCheck(object, testRti);
    },
    _failedAsCheck: function(object, testRti) {
      throw H.wrapException(H._TypeError$fromMessage(H._Error_compose(object, H.instanceOrFunctionType(object, testRti), H._rtiToString(testRti, null))));
    },
    _Error_compose: function(object, objectRti, checkedTypeDescription) {
      var objectDescription = P.Error_safeToString(object),
        objectTypeDescription = H._rtiToString(objectRti == null ? H.instanceType(object) : objectRti, null);
      return objectDescription + ": type '" + objectTypeDescription + "' is not a subtype of type '" + checkedTypeDescription + "'";
    },
    _TypeError$fromMessage: function(message) {
      return new H._TypeError("TypeError: " + message);
    },
    _TypeError__TypeError$forType: function(object, type) {
      return H._TypeError$fromMessage(H._Error_compose(object, null, type));
    },
    _isObject: function(object) {
      return object != null;
    },
    _asObject: function(object) {
      if (object != null)
        return object;
      throw H.wrapException(H._TypeError__TypeError$forType(object, "Object"));
    },
    _isTop: function(object) {
      return true;
    },
    _asTop: function(object) {
      return object;
    },
    _isBool: function(object) {
      return true === object || false === object;
    },
    _asBool: function(object) {
      if (true === object)
        return true;
      if (false === object)
        return false;
      throw H.wrapException(H._TypeError__TypeError$forType(object, "bool"));
    },
    _asBoolS: function(object) {
      if (true === object)
        return true;
      if (false === object)
        return false;
      if (object == null)
        return object;
      throw H.wrapException(H._TypeError__TypeError$forType(object, "bool"));
    },
    _asBoolQ: function(object) {
      if (true === object)
        return true;
      if (false === object)
        return false;
      if (object == null)
        return object;
      throw H.wrapException(H._TypeError__TypeError$forType(object, "bool?"));
    },
    _asDouble: function(object) {
      if (H._isNum(object))
        return H._Utils_asDouble(object);
      throw H.wrapException(H._TypeError__TypeError$forType(object, "double"));
    },
    _asDoubleS: function(object) {
      if (H._isNum(object))
        return H._Utils_asDouble(object);
      if (object == null)
        return object;
      throw H.wrapException(H._TypeError__TypeError$forType(object, "double"));
    },
    _asDoubleQ: function(object) {
      if (H._isNum(object))
        return H._Utils_asDouble(object);
      if (object == null)
        return object;
      throw H.wrapException(H._TypeError__TypeError$forType(object, "double?"));
    },
    _isInt: function(object) {
      return typeof object == "number" && Math.floor(object) === object;
    },
    _asInt: function(object) {
      if (H._isInt(object))
        return H._Utils_asInt(object);
      throw H.wrapException(H._TypeError__TypeError$forType(object, "int"));
    },
    _asIntS: function(object) {
      if (H._isInt(object))
        return H._Utils_asInt(object);
      if (object == null)
        return object;
      throw H.wrapException(H._TypeError__TypeError$forType(object, "int"));
    },
    _asIntQ: function(object) {
      if (H._isInt(object))
        return H._Utils_asInt(object);
      if (object == null)
        return object;
      throw H.wrapException(H._TypeError__TypeError$forType(object, "int?"));
    },
    _isNum: function(object) {
      return typeof object == "number";
    },
    _asNum: function(object) {
      if (H._isNum(object))
        return H._Utils_asNum(object);
      throw H.wrapException(H._TypeError__TypeError$forType(object, "num"));
    },
    _asNumS: function(object) {
      if (H._isNum(object))
        return H._Utils_asNum(object);
      if (object == null)
        return object;
      throw H.wrapException(H._TypeError__TypeError$forType(object, "num"));
    },
    _asNumQ: function(object) {
      if (H._isNum(object))
        return H._Utils_asNum(object);
      if (object == null)
        return object;
      throw H.wrapException(H._TypeError__TypeError$forType(object, "num?"));
    },
    _isString: function(object) {
      return typeof object == "string";
    },
    _asString: function(object) {
      if (H._isString(object))
        return H._Utils_asString(object);
      throw H.wrapException(H._TypeError__TypeError$forType(object, "String"));
    },
    _asStringS: function(object) {
      if (H._isString(object))
        return H._Utils_asString(object);
      if (object == null)
        return object;
      throw H.wrapException(H._TypeError__TypeError$forType(object, "String"));
    },
    _asStringQ: function(object) {
      if (H._isString(object))
        return H._Utils_asString(object);
      if (object == null)
        return object;
      throw H.wrapException(H._TypeError__TypeError$forType(object, "String?"));
    },
    _rtiArrayToString: function(array, genericContext) {
      var s, sep, i;
      for (s = "", sep = "", i = 0; i < H._Utils_arrayLength(array); ++i, sep = ", ")
        s += C.JSString_methods.$add(sep, H._rtiToString(H._Utils_asRti(H._Utils_arrayAt(array, i)), genericContext));
      return s;
    },
    _functionRtiToString: function(functionType, genericContext, bounds) {
      var boundsLength, outerContextLength, offset, i, typeParametersText, typeSep, t1, t2, boundRti, returnType, parameters, requiredPositional, requiredPositionalLength, optionalPositional, optionalPositionalLength, named, namedLength, returnTypeText, argumentsText, sep, _s2_ = ", ";
      if (bounds != null) {
        boundsLength = H._Utils_arrayLength(bounds);
        if (genericContext == null) {
          genericContext = H.setRuntimeTypeInfo([], type$.JSArray_String);
          outerContextLength = null;
        } else
          outerContextLength = genericContext.length;
        offset = genericContext.length;
        for (i = boundsLength; i > 0; --i)
          C.JSArray_methods.add$1(genericContext, "T" + (offset + i));
        for (typeParametersText = "<", typeSep = "", i = 0; i < boundsLength; ++i, typeSep = _s2_) {
          typeParametersText += typeSep;
          t1 = genericContext.length;
          t2 = t1 - 1 - i;
          if (t2 < 0)
            return H.ioore(genericContext, t2);
          typeParametersText = C.JSString_methods.$add(typeParametersText, genericContext[t2]);
          boundRti = H._Utils_asRti(H._Utils_arrayAt(bounds, i));
          if (!H.isTopType(boundRti))
            typeParametersText += C.JSString_methods.$add(" extends ", H._rtiToString(boundRti, genericContext));
        }
        typeParametersText += ">";
      } else {
        typeParametersText = "";
        outerContextLength = null;
      }
      returnType = H.Rti__getReturnType(functionType);
      parameters = H.Rti__getFunctionParameters(functionType);
      requiredPositional = H._FunctionParameters__getRequiredPositional(parameters);
      requiredPositionalLength = H._Utils_arrayLength(requiredPositional);
      optionalPositional = H._FunctionParameters__getOptionalPositional(parameters);
      optionalPositionalLength = H._Utils_arrayLength(optionalPositional);
      named = H._FunctionParameters__getNamed(parameters);
      namedLength = H._Utils_arrayLength(named);
      H.assertHelper(optionalPositionalLength === 0 || namedLength === 0);
      returnTypeText = H._rtiToString(returnType, genericContext);
      for (argumentsText = "", sep = "", i = 0; i < requiredPositionalLength; ++i, sep = _s2_)
        argumentsText += C.JSString_methods.$add(sep, H._rtiToString(H._Utils_asRti(H._Utils_arrayAt(requiredPositional, i)), genericContext));
      if (optionalPositionalLength > 0) {
        argumentsText += sep + "[";
        for (sep = "", i = 0; i < optionalPositionalLength; ++i, sep = _s2_)
          argumentsText += C.JSString_methods.$add(sep, H._rtiToString(H._Utils_asRti(H._Utils_arrayAt(optionalPositional, i)), genericContext));
        argumentsText += "]";
      }
      if (namedLength > 0) {
        argumentsText += sep + "{";
        for (sep = "", i = 0; i < namedLength; i += 3, sep = _s2_) {
          argumentsText += sep;
          if (H._Utils_asBool(H._Utils_arrayAt(named, i + 1)))
            argumentsText += "required ";
          argumentsText += J.$add$ns(H._rtiToString(H._Utils_asRti(H._Utils_arrayAt(named, i + 2)), genericContext), " ") + H._Utils_asString(H._Utils_arrayAt(named, i));
        }
        argumentsText += "}";
      }
      if (outerContextLength != null) {
        genericContext.toString;
        genericContext.length = outerContextLength;
      }
      return typeParametersText + "(" + argumentsText + ") => " + returnTypeText;
    },
    _rtiToString: function(rti, genericContext) {
      var s, questionArgument, argumentKind, $name, $arguments, index, t1, t2,
        kind = H.Rti__getKind(rti);
      if (kind === 5)
        return "erased";
      if (kind === 2)
        return "dynamic";
      if (kind === 3)
        return "void";
      if (kind === 1)
        return "Never";
      if (kind === 4)
        return "any";
      if (kind === 6) {
        s = H._rtiToString(H.Rti__getStarArgument(rti), genericContext);
        return s;
      }
      if (kind === 7) {
        questionArgument = H.Rti__getQuestionArgument(rti);
        s = H._rtiToString(questionArgument, genericContext);
        argumentKind = H.Rti__getKind(questionArgument);
        return (argumentKind === 11 || argumentKind === 12 ? "(" + s + ")" : s) + "?";
      }
      if (kind === 8)
        return "FutureOr<" + H.S(H._rtiToString(H.Rti__getFutureOrArgument(rti), genericContext)) + ">";
      if (kind === 9) {
        $name = H._unminifyOrTag(H.Rti__getInterfaceName(rti));
        $arguments = H.Rti__getInterfaceTypeArguments(rti);
        return $arguments.length !== 0 ? $name + ("<" + H._rtiArrayToString($arguments, genericContext) + ">") : $name;
      }
      if (kind === 11)
        return H._functionRtiToString(rti, genericContext, null);
      if (kind === 12)
        return H._functionRtiToString(H.Rti__getGenericFunctionBase(rti), genericContext, H.Rti__getGenericFunctionBounds(rti));
      if (kind === 13) {
        genericContext.toString;
        index = H.Rti__getGenericFunctionParameterIndex(rti);
        t1 = genericContext.length;
        t2 = t1 - 1 - index;
        if (t2 < 0 || t2 >= t1)
          return H.ioore(genericContext, t2);
        return genericContext[t2];
      }
      return "?";
    },
    _unminifyOrTag: function(rawClassName) {
      var preserved = H.unmangleGlobalNameIfPreservedAnyways(rawClassName);
      if (preserved != null)
        return preserved;
      return rawClassName;
    },
    _Universe_evalCache: function(universe) {
      return universe.eC;
    },
    _Universe_typeRules: function(universe) {
      return universe.tR;
    },
    _Universe_erasedTypes: function(universe) {
      return universe.eT;
    },
    _Universe__findRule: function(universe, targetType) {
      return H._Universe_typeRules(universe)[targetType];
    },
    _Universe_findRule: function(universe, targetType) {
      var rule = H._Universe__findRule(universe, targetType);
      for (; H._Utils_isString(rule);)
        rule = H._Universe__findRule(universe, H._Utils_asString(rule));
      return rule;
    },
    _Universe_findErasedType: function(universe, cls) {
      var $length, erased, $arguments, i, $interface,
        metadata = H._Universe_erasedTypes(universe),
        probe = metadata[cls];
      if (probe == null)
        return H._Universe_eval(universe, cls, false);
      else if (H._Utils_isNum(probe)) {
        $length = H._Utils_asInt(probe);
        erased = H._Universe__lookupErasedRti(universe);
        $arguments = [];
        for (i = 0; i < $length; ++i)
          H._Utils_arrayPush($arguments, erased);
        $interface = H._Universe__lookupInterfaceRti(universe, cls, $arguments);
        metadata[cls] = $interface;
        return $interface;
      } else
        return H._Utils_asRti(probe);
    },
    _Universe_addRules: function(universe, rules) {
      return H._Utils_objectAssign(H._Universe_typeRules(universe), rules);
    },
    _Universe_addErasedTypes: function(universe, types) {
      return H._Utils_objectAssign(H._Universe_erasedTypes(universe), types);
    },
    _Universe_sharedEmptyArray: function(universe) {
      return universe.sEA;
    },
    _Universe_eval: function(universe, recipe, normalize) {
      var rti,
        cache = H._Universe_evalCache(universe),
        probe = H._Utils_mapGet(cache, recipe);
      if (probe != null)
        return H._Utils_asRti(probe);
      rti = H._Universe__parseRecipe(universe, null, recipe, normalize);
      H._Utils_mapSet(cache, recipe, rti);
      return rti;
    },
    _Universe_evalInEnvironment: function(universe, environment, recipe) {
      var probe, rti,
        cache = H.Rti__getEvalCache(environment);
      if (cache == null) {
        cache = new Map();
        H.Rti__setEvalCache(environment, cache);
      }
      probe = H._Utils_mapGet(cache, recipe);
      if (probe != null)
        return H._Utils_asRti(probe);
      rti = H._Universe__parseRecipe(universe, environment, recipe, true);
      H._Utils_mapSet(cache, recipe, rti);
      return rti;
    },
    _Universe_bind: function(universe, environment, argumentsRti) {
      var argumentsRecipe, probe, rti,
        cache = H.Rti__getBindCache(environment);
      if (cache == null) {
        cache = new Map();
        H.Rti__setBindCache(environment, cache);
      }
      argumentsRecipe = H.Rti__getCanonicalRecipe(argumentsRti);
      probe = H._Utils_mapGet(cache, argumentsRecipe);
      if (probe != null)
        return H._Utils_asRti(probe);
      rti = H._Universe__lookupBindingRti(universe, environment, H.Rti__getKind(argumentsRti) === 10 ? H.Rti__getBindingArguments(argumentsRti) : [argumentsRti]);
      H._Utils_mapSet(cache, argumentsRecipe, rti);
      return rti;
    },
    _Universe_evalTypeVariable: function(universe, environment, $name) {
      var rule, recipe;
      if (H.Rti__getKind(environment) === 10)
        environment = H.Rti__getBindingBase(environment);
      rule = H._Universe_findRule(universe, H.Rti__getInterfaceName(environment));
      H.assertHelper(rule != null);
      recipe = H.TypeRule_lookupTypeVariable(rule, $name);
      if (recipe == null)
        throw H.wrapException('No "' + $name + '" in "' + H.Rti__getCanonicalRecipe(environment) + '"');
      return H._Universe_evalInEnvironment(universe, environment, recipe);
    },
    _Universe__parseRecipe: function(universe, environment, recipe, normalize) {
      return H._Parser_parse(H._Parser_create(universe, environment, recipe, normalize));
    },
    _Universe__installTypeTests: function(universe, rti) {
      H.Rti__setAsCheckFunction(rti, H._installSpecializedAsCheck);
      H.Rti__setIsTestFunction(rti, H._installSpecializedIsTest);
      return rti;
    },
    _Universe__installRti: function(universe, key, rti) {
      H._Utils_mapSet(H._Universe_evalCache(universe), key, rti);
      return rti;
    },
    _Universe__recipeJoin: function(s1, s2) {
      return s1 + s2;
    },
    _Universe__recipeJoin3: function(s1, s2, s3) {
      return s1 + (s2 + s3);
    },
    _Universe__recipeJoin4: function(s1, s2, s3, s4) {
      return s1 + (s2 + s3 + s4);
    },
    _Universe__recipeJoin5: function(s1, s2, s3, s4, s5) {
      return s1 + (s2 + s3 + s4 + s5);
    },
    _Universe__canonicalRecipeOfErased: function() {
      return "#";
    },
    _Universe__canonicalRecipeOfDynamic: function() {
      return "@";
    },
    _Universe__canonicalRecipeOfVoid: function() {
      return "~";
    },
    _Universe__canonicalRecipeOfNever: function() {
      return H._Universe__recipeJoin("0", "&");
    },
    _Universe__canonicalRecipeOfAny: function() {
      return H._Universe__recipeJoin("1", "&");
    },
    _Universe__canonicalRecipeOfStar: function(baseType) {
      return H._Universe__recipeJoin(H.Rti__getCanonicalRecipe(baseType), "*");
    },
    _Universe__canonicalRecipeOfQuestion: function(baseType) {
      return H._Universe__recipeJoin(H.Rti__getCanonicalRecipe(baseType), "?");
    },
    _Universe__canonicalRecipeOfFutureOr: function(baseType) {
      return H._Universe__recipeJoin(H.Rti__getCanonicalRecipe(baseType), "/");
    },
    _Universe__canonicalRecipeOfGenericFunctionParameter: function(index) {
      return H._Universe__recipeJoin("" + index, "^");
    },
    _Universe__lookupErasedRti: function(universe) {
      return H._Universe__lookupTerminalRti(universe, 5, H._Universe__canonicalRecipeOfErased());
    },
    _Universe__lookupDynamicRti: function(universe) {
      return H._Universe__lookupTerminalRti(universe, 2, H._Universe__canonicalRecipeOfDynamic());
    },
    _Universe__lookupVoidRti: function(universe) {
      return H._Universe__lookupTerminalRti(universe, 3, H._Universe__canonicalRecipeOfVoid());
    },
    _Universe__lookupNeverRti: function(universe) {
      return H._Universe__lookupTerminalRti(universe, 1, H._Universe__canonicalRecipeOfNever());
    },
    _Universe__lookupAnyRti: function(universe) {
      return H._Universe__lookupTerminalRti(universe, 4, H._Universe__canonicalRecipeOfAny());
    },
    _Universe__lookupTerminalRti: function(universe, kind, key) {
      var probe = H._Utils_mapGet(H._Universe_evalCache(universe), key);
      if (probe != null)
        return H._Utils_asRti(probe);
      return H._Universe__installRti(universe, key, H._Universe__createTerminalRti(universe, kind, key));
    },
    _Universe__createTerminalRti: function(universe, kind, key) {
      var rti = H.Rti_allocate();
      H.Rti__setKind(rti, kind);
      H.Rti__setCanonicalRecipe(rti, key);
      return H._Universe__installTypeTests(universe, rti);
    },
    _Universe__lookupStarRti: function(universe, baseType, normalize) {
      var key = H._Universe__canonicalRecipeOfStar(baseType),
        probe = H._Utils_mapGet(H._Universe_evalCache(universe), key);
      if (probe != null)
        return H._Utils_asRti(probe);
      return H._Universe__installRti(universe, key, H._Universe__createStarRti(universe, baseType, key, normalize));
    },
    _Universe__createStarRti: function(universe, baseType, key, normalize) {
      var baseKind, rti;
      if (normalize) {
        baseKind = H.Rti__getKind(baseType);
        if (H.isStrongTopType(baseType) || H.isNullType(baseType) || baseKind === 7 || baseKind === 6)
          return baseType;
      }
      rti = H.Rti_allocate();
      H.Rti__setKind(rti, 6);
      H.Rti__setPrimary(rti, baseType);
      H.Rti__setCanonicalRecipe(rti, key);
      return H._Universe__installTypeTests(universe, rti);
    },
    _Universe__lookupQuestionRti: function(universe, baseType, normalize) {
      var key = H._Universe__canonicalRecipeOfQuestion(baseType),
        probe = H._Utils_mapGet(H._Universe_evalCache(universe), key);
      if (probe != null)
        return H._Utils_asRti(probe);
      return H._Universe__installRti(universe, key, H._Universe__createQuestionRti(universe, baseType, key, normalize));
    },
    _Universe__createQuestionRti: function(universe, baseType, key, normalize) {
      var baseKind, t1, starArgument, rti;
      if (normalize) {
        baseKind = H.Rti__getKind(baseType);
        if (!H.isStrongTopType(baseType))
          if (!H.isNullType(baseType))
            if (baseKind !== 7)
              t1 = baseKind === 8 && H.isNullable(H.Rti__getFutureOrArgument(baseType));
            else
              t1 = true;
          else
            t1 = true;
        else
          t1 = true;
        if (t1)
          return baseType;
        else if (baseKind === 1 || H._Utils_isIdentical(baseType, type$.legacy_Never))
          return type$.Null;
        else if (baseKind === 6) {
          starArgument = H.Rti__getStarArgument(baseType);
          if (H.Rti__getKind(starArgument) === 8 && H.isNullable(H.Rti__getFutureOrArgument(starArgument)))
            return starArgument;
          else
            return H.Rti__getQuestionFromStar(universe, baseType);
        }
      }
      rti = H.Rti_allocate();
      H.Rti__setKind(rti, 7);
      H.Rti__setPrimary(rti, baseType);
      H.Rti__setCanonicalRecipe(rti, key);
      return H._Universe__installTypeTests(universe, rti);
    },
    _Universe__lookupFutureOrRti: function(universe, baseType, normalize) {
      var key = H._Universe__canonicalRecipeOfFutureOr(baseType),
        probe = H._Utils_mapGet(H._Universe_evalCache(universe), key);
      if (probe != null)
        return H._Utils_asRti(probe);
      return H._Universe__installRti(universe, key, H._Universe__createFutureOrRti(universe, baseType, key, normalize));
    },
    _Universe__createFutureOrRti: function(universe, baseType, key, normalize) {
      var baseKind, rti;
      if (normalize) {
        baseKind = H.Rti__getKind(baseType);
        if (H.isTopType(baseType) || H.isObjectType(baseType))
          return baseType;
        else if (baseKind === 1)
          return H._Universe__lookupFutureRti(universe, baseType);
        else if (H.isNullType(baseType))
          return type$.nullable_Future_Null;
      }
      rti = H.Rti_allocate();
      H.Rti__setKind(rti, 8);
      H.Rti__setPrimary(rti, baseType);
      H.Rti__setCanonicalRecipe(rti, key);
      return H._Universe__installTypeTests(universe, rti);
    },
    _Universe__lookupGenericFunctionParameterRti: function(universe, index) {
      var key = H._Universe__canonicalRecipeOfGenericFunctionParameter(index),
        probe = H._Utils_mapGet(H._Universe_evalCache(universe), key);
      if (probe != null)
        return H._Utils_asRti(probe);
      return H._Universe__installRti(universe, key, H._Universe__createGenericFunctionParameterRti(universe, index, key));
    },
    _Universe__createGenericFunctionParameterRti: function(universe, index, key) {
      var rti = H.Rti_allocate();
      H.Rti__setKind(rti, 13);
      H.Rti__setPrimary(rti, index);
      H.Rti__setCanonicalRecipe(rti, key);
      return H._Universe__installTypeTests(universe, rti);
    },
    _Universe__canonicalRecipeJoin: function($arguments) {
      var s, sep, i,
        $length = H._Utils_arrayLength($arguments);
      for (s = "", sep = "", i = 0; i < $length; ++i, sep = ",")
        s = H._Universe__recipeJoin3(s, sep, H.Rti__getCanonicalRecipe(H._Utils_asRti(H._Utils_arrayAt($arguments, i))));
      return s;
    },
    _Universe__canonicalRecipeJoinNamed: function($arguments) {
      var s, sep, i, $name, nameSep,
        $length = H._Utils_arrayLength($arguments);
      H.assertHelper(H._Utils_isMultipleOf($length, 3));
      for (s = "", sep = "", i = 0; i < $length; i += 3, sep = ",") {
        $name = H._Utils_asString(H._Utils_arrayAt($arguments, i));
        nameSep = H._Utils_asBool(H._Utils_arrayAt($arguments, i + 1)) ? "!" : ":";
        s = H._Universe__recipeJoin5(s, sep, $name, nameSep, H.Rti__getCanonicalRecipe(H._Utils_asRti(H._Utils_arrayAt($arguments, i + 2))));
      }
      return s;
    },
    _Universe__canonicalRecipeOfInterface: function($name, $arguments) {
      var s;
      H.assertHelper(H._Utils_isString($name));
      s = H._Utils_asString($name);
      return H._Utils_arrayLength($arguments) !== 0 ? H._Universe__recipeJoin4(s, "<", H._Universe__canonicalRecipeJoin($arguments), ">") : s;
    },
    _Universe__lookupInterfaceRti: function(universe, $name, $arguments) {
      var key = H._Universe__canonicalRecipeOfInterface($name, $arguments),
        probe = H._Utils_mapGet(H._Universe_evalCache(universe), key);
      if (probe != null)
        return H._Utils_asRti(probe);
      return H._Universe__installRti(universe, key, H._Universe__createInterfaceRti(universe, $name, $arguments, key));
    },
    _Universe__createInterfaceRti: function(universe, $name, typeArguments, key) {
      var rti = H.Rti_allocate();
      H.Rti__setKind(rti, 9);
      H.Rti__setPrimary(rti, $name);
      H.Rti__setRest(rti, typeArguments);
      if (H._Utils_arrayLength(typeArguments) > 0)
        H.Rti__setPrecomputed1(rti, H._Utils_arrayAt(typeArguments, 0));
      H.Rti__setCanonicalRecipe(rti, key);
      return H._Universe__installTypeTests(universe, rti);
    },
    _Universe__lookupFutureRti: function(universe, base) {
      return H._Universe__lookupInterfaceRti(universe, "Future", [base]);
    },
    _Universe__canonicalRecipeOfBinding: function(base, $arguments) {
      return H._Universe__recipeJoin5(H.Rti__getCanonicalRecipe(base), ";", "<", H._Universe__canonicalRecipeJoin($arguments), ">");
    },
    _Universe__lookupBindingRti: function(universe, base, $arguments) {
      var newBase, newArguments, key, probe;
      if (H.Rti__getKind(base) === 10) {
        newBase = H.Rti__getBindingBase(base);
        newArguments = H._Utils_arrayConcat(H.Rti__getBindingArguments(base), $arguments);
      } else {
        newArguments = $arguments;
        newBase = base;
      }
      key = H._Universe__canonicalRecipeOfBinding(newBase, newArguments);
      probe = H._Utils_mapGet(H._Universe_evalCache(universe), key);
      if (probe != null)
        return H._Utils_asRti(probe);
      return H._Universe__installRti(universe, key, H._Universe__createBindingRti(universe, newBase, newArguments, key));
    },
    _Universe__createBindingRti: function(universe, base, $arguments, key) {
      var rti = H.Rti_allocate();
      H.Rti__setKind(rti, 10);
      H.Rti__setPrimary(rti, base);
      H.Rti__setRest(rti, $arguments);
      H.Rti__setCanonicalRecipe(rti, key);
      return H._Universe__installTypeTests(universe, rti);
    },
    _Universe__canonicalRecipeOfFunction: function(returnType, parameters) {
      return H._Universe__recipeJoin(H.Rti__getCanonicalRecipe(returnType), H._Universe__canonicalRecipeOfFunctionParameters(parameters));
    },
    _Universe__canonicalRecipeOfFunctionParameters: function(parameters) {
      var recipe, sep,
        requiredPositional = H._FunctionParameters__getRequiredPositional(parameters),
        requiredPositionalLength = H._Utils_arrayLength(requiredPositional),
        optionalPositional = H._FunctionParameters__getOptionalPositional(parameters),
        optionalPositionalLength = H._Utils_arrayLength(optionalPositional),
        named = H._FunctionParameters__getNamed(parameters),
        namedLength = H._Utils_arrayLength(named);
      H.assertHelper(optionalPositionalLength === 0 || namedLength === 0);
      recipe = H._Universe__recipeJoin("(", H._Universe__canonicalRecipeJoin(requiredPositional));
      if (optionalPositionalLength > 0) {
        sep = requiredPositionalLength > 0 ? "," : "";
        recipe = H._Universe__recipeJoin5(recipe, sep, "[", H._Universe__canonicalRecipeJoin(optionalPositional), "]");
      }
      if (namedLength > 0) {
        sep = requiredPositionalLength > 0 ? "," : "";
        recipe = H._Universe__recipeJoin5(recipe, sep, "{", H._Universe__canonicalRecipeJoinNamed(named), "}");
      }
      return H._Universe__recipeJoin(recipe, ")");
    },
    _Universe__lookupFunctionRti: function(universe, returnType, parameters) {
      var key = H._Universe__canonicalRecipeOfFunction(returnType, parameters),
        probe = H._Utils_mapGet(H._Universe_evalCache(universe), key);
      if (probe != null)
        return H._Utils_asRti(probe);
      return H._Universe__installRti(universe, key, H._Universe__createFunctionRti(universe, returnType, parameters, key));
    },
    _Universe__createFunctionRti: function(universe, returnType, parameters, key) {
      var rti = H.Rti_allocate();
      H.Rti__setKind(rti, 11);
      H.Rti__setPrimary(rti, returnType);
      H.Rti__setRest(rti, parameters);
      H.Rti__setCanonicalRecipe(rti, key);
      return H._Universe__installTypeTests(universe, rti);
    },
    _Universe__canonicalRecipeOfGenericFunction: function(baseFunctionType, bounds) {
      return H._Universe__recipeJoin4(H.Rti__getCanonicalRecipe(baseFunctionType), "<", H._Universe__canonicalRecipeJoin(bounds), ">");
    },
    _Universe__lookupGenericFunctionRti: function(universe, baseFunctionType, bounds, normalize) {
      var key = H._Universe__canonicalRecipeOfGenericFunction(baseFunctionType, bounds),
        probe = H._Utils_mapGet(H._Universe_evalCache(universe), key);
      if (probe != null)
        return H._Utils_asRti(probe);
      return H._Universe__installRti(universe, key, H._Universe__createGenericFunctionRti(universe, baseFunctionType, bounds, key, normalize));
    },
    _Universe__createGenericFunctionRti: function(universe, baseFunctionType, bounds, key, normalize) {
      var $length, typeArguments, count, i, bound, substitutedBase, substitutedBounds, rti;
      if (normalize) {
        $length = H._Utils_arrayLength(bounds);
        typeArguments = new Array($length);
        for (count = 0, i = 0; i < $length; ++i) {
          bound = H._Utils_asRti(H._Utils_arrayAt(bounds, i));
          if (H.Rti__getKind(bound) === 1) {
            H._Utils_arraySetAt(typeArguments, i, bound);
            ++count;
          }
        }
        if (count > 0) {
          substitutedBase = H._substitute(universe, baseFunctionType, typeArguments, 0);
          substitutedBounds = H._substituteArray(universe, bounds, typeArguments, 0);
          return H._Universe__lookupGenericFunctionRti(universe, substitutedBase, substitutedBounds, H._Utils_isNotIdentical(bounds, substitutedBounds));
        }
      }
      rti = H.Rti_allocate();
      H.Rti__setKind(rti, 12);
      H.Rti__setPrimary(rti, baseFunctionType);
      H.Rti__setRest(rti, bounds);
      H.Rti__setCanonicalRecipe(rti, key);
      return H._Universe__installTypeTests(universe, rti);
    },
    _Parser_create: function(universe, environment, recipe, normalize) {
      return {u: universe, e: environment, r: recipe, s: [], p: 0, n: normalize};
    },
    _Parser_universe: function(parser) {
      return parser.u;
    },
    _Parser_environment: function(parser) {
      return parser.e;
    },
    _Parser_recipe: function(parser) {
      return parser.r;
    },
    _Parser_stack: function(parser) {
      return parser.s;
    },
    _Parser_position: function(parser) {
      return parser.p;
    },
    _Parser_setPosition: function(parser, p) {
      parser.p = p;
    },
    _Parser_normalize: function(parser) {
      return parser.n;
    },
    _Parser_charCodeAt: function(s, i) {
      return s.charCodeAt(i);
    },
    _Parser_push: function(stack, value) {
      stack.push(value);
    },
    _Parser_pop: function(stack) {
      return stack.pop();
    },
    _Parser_parse: function(parser) {
      var t1, i, ch, u, item,
        source = H._Parser_recipe(parser),
        stack = H._Parser_stack(parser);
      for (t1 = source.length, i = 0; i < t1;) {
        ch = H._Parser_charCodeAt(source, i);
        if (H.Recipe_isDigit(ch))
          i = H._Parser_handleDigit(i + 1, ch, source, stack);
        else if (H.Recipe_isIdentifierStart(ch))
          i = H._Parser_handleIdentifier(parser, i, source, stack, false);
        else if (ch === 46)
          i = H._Parser_handleIdentifier(parser, i, source, stack, true);
        else {
          ++i;
          switch (ch) {
            case 44:
              break;
            case 58:
              H._Parser_push(stack, false);
              break;
            case 33:
              H._Parser_push(stack, true);
              break;
            case 59:
              H._Parser_push(stack, H._Parser_toType(H._Parser_universe(parser), H._Parser_environment(parser), H._Parser_pop(stack)));
              break;
            case 94:
              H._Parser_push(stack, H._Parser_toGenericFunctionParameter(H._Parser_universe(parser), H._Parser_pop(stack)));
              break;
            case 35:
              H._Parser_push(stack, H._Universe__lookupErasedRti(H._Parser_universe(parser)));
              break;
            case 64:
              H._Parser_push(stack, H._Universe__lookupDynamicRti(H._Parser_universe(parser)));
              break;
            case 126:
              H._Parser_push(stack, H._Universe__lookupVoidRti(H._Parser_universe(parser)));
              break;
            case 60:
              H._Parser_pushStackFrame(parser, stack);
              break;
            case 62:
              H._Parser_handleTypeArguments(parser, stack);
              break;
            case 38:
              H._Parser_handleExtendedOperations(parser, stack);
              break;
            case 42:
              u = H._Parser_universe(parser);
              H._Parser_push(stack, H._Universe__lookupStarRti(u, H._Parser_toType(u, H._Parser_environment(parser), H._Parser_pop(stack)), H._Parser_normalize(parser)));
              break;
            case 63:
              u = H._Parser_universe(parser);
              H._Parser_push(stack, H._Universe__lookupQuestionRti(u, H._Parser_toType(u, H._Parser_environment(parser), H._Parser_pop(stack)), H._Parser_normalize(parser)));
              break;
            case 47:
              u = H._Parser_universe(parser);
              H._Parser_push(stack, H._Universe__lookupFutureOrRti(u, H._Parser_toType(u, H._Parser_environment(parser), H._Parser_pop(stack)), H._Parser_normalize(parser)));
              break;
            case 40:
              H._Parser_pushStackFrame(parser, stack);
              break;
            case 41:
              H._Parser_handleFunctionArguments(parser, stack);
              break;
            case 91:
              H._Parser_pushStackFrame(parser, stack);
              break;
            case 93:
              H._Parser_handleOptionalGroup(parser, stack);
              break;
            case 123:
              H._Parser_pushStackFrame(parser, stack);
              break;
            case 125:
              H._Parser_handleNamedGroup(parser, stack);
              break;
            default:
              throw "Bad character " + ch;
          }
        }
      }
      item = H._Parser_pop(stack);
      return H._Parser_toType(H._Parser_universe(parser), H._Parser_environment(parser), item);
    },
    _Parser_pushStackFrame: function(parser, stack) {
      H._Parser_push(stack, H._Parser_position(parser));
      H._Parser_setPosition(parser, H._Utils_arrayLength(stack));
    },
    _Parser_handleDigit: function(i, digit, source, stack) {
      var t1, ch,
        value = H.Recipe_digitValue(digit);
      for (t1 = source.length; i < t1; ++i) {
        ch = H._Parser_charCodeAt(source, i);
        if (!H.Recipe_isDigit(ch))
          break;
        value = value * 10 + H.Recipe_digitValue(ch);
      }
      H._Parser_push(stack, value);
      return i;
    },
    _Parser_handleIdentifier: function(parser, start, source, stack, hasPeriod) {
      var t1, ch, string,
        i = start + 1;
      for (t1 = source.length; i < t1; ++i) {
        ch = H._Parser_charCodeAt(source, i);
        if (ch === 46) {
          if (hasPeriod)
            break;
          hasPeriod = true;
        } else if (!(H.Recipe_isIdentifierStart(ch) || H.Recipe_isDigit(ch)))
          break;
      }
      string = H._Utils_substring(source, start, i);
      if (hasPeriod)
        H._Parser_push(stack, H._Universe_evalTypeVariable(H._Parser_universe(parser), H._Parser_environment(parser), string));
      else
        H._Parser_push(stack, string);
      return i;
    },
    _Parser_handleTypeArguments: function(parser, stack) {
      var base,
        universe = H._Parser_universe(parser),
        $arguments = H._Parser_collectArray(parser, stack),
        head = H._Parser_pop(stack);
      if (H._Utils_isString(head))
        H._Parser_push(stack, H._Universe__lookupInterfaceRti(universe, H._Utils_asString(head), $arguments));
      else {
        base = H._Parser_toType(universe, H._Parser_environment(parser), head);
        switch (H.Rti__getKind(base)) {
          case 11:
            H._Parser_push(stack, H._Universe__lookupGenericFunctionRti(universe, base, $arguments, H._Parser_normalize(parser)));
            break;
          default:
            H._Parser_push(stack, H._Universe__lookupBindingRti(universe, base, $arguments));
            break;
        }
      }
    },
    _Parser_handleFunctionArguments: function(parser, stack) {
      var universe = H._Parser_universe(parser),
        parameters = H._FunctionParameters_allocate(),
        optionalPositional = H._Universe_sharedEmptyArray(universe),
        named = H._Universe_sharedEmptyArray(universe),
        head = H._Parser_pop(stack);
      if (H._Utils_isNum(head))
        switch (H._Utils_asInt(head)) {
          case -1:
            optionalPositional = H._Parser_pop(stack);
            break;
          case -2:
            named = H._Parser_pop(stack);
            break;
          default:
            H._Parser_push(stack, head);
            break;
        }
      else
        H._Parser_push(stack, head);
      H._FunctionParameters__setRequiredPositional(parameters, H._Parser_collectArray(parser, stack));
      H._FunctionParameters__setOptionalPositional(parameters, optionalPositional);
      H._FunctionParameters__setNamed(parameters, named);
      H._Parser_push(stack, H._Universe__lookupFunctionRti(universe, H._Parser_toType(universe, H._Parser_environment(parser), H._Parser_pop(stack)), parameters));
    },
    _Parser_handleOptionalGroup: function(parser, stack) {
      H._Parser_push(stack, H._Parser_collectArray(parser, stack));
      H._Parser_push(stack, -1);
    },
    _Parser_handleNamedGroup: function(parser, stack) {
      H._Parser_push(stack, H._Parser_collectNamed(parser, stack));
      H._Parser_push(stack, -2);
    },
    _Parser_handleExtendedOperations: function(parser, stack) {
      var $top = H._Parser_pop(stack);
      if (0 === $top) {
        H._Parser_push(stack, H._Universe__lookupNeverRti(H._Parser_universe(parser)));
        return;
      }
      if (1 === $top) {
        H._Parser_push(stack, H._Universe__lookupAnyRti(H._Parser_universe(parser)));
        return;
      }
      throw H.wrapException(P.AssertionError$("Unexpected extended operation " + H.S($top)));
    },
    _Parser_collectArray: function(parser, stack) {
      var array = H._Utils_arraySplice(stack, H._Parser_position(parser));
      H._Parser_toTypes(H._Parser_universe(parser), H._Parser_environment(parser), array);
      H._Parser_setPosition(parser, H._Utils_asInt(H._Parser_pop(stack)));
      return array;
    },
    _Parser_collectNamed: function(parser, stack) {
      var array = H._Utils_arraySplice(stack, H._Parser_position(parser));
      H._Parser_toTypesNamed(H._Parser_universe(parser), H._Parser_environment(parser), array);
      H._Parser_setPosition(parser, H._Utils_asInt(H._Parser_pop(stack)));
      return array;
    },
    _Parser_toType: function(universe, environment, item) {
      if (H._Utils_isString(item))
        return H._Universe__lookupInterfaceRti(universe, H._Utils_asString(item), H._Universe_sharedEmptyArray(universe));
      else if (H._Utils_isNum(item))
        return H._Parser_indexToType(universe, environment, H._Utils_asInt(item));
      else
        return H._Utils_asRti(item);
    },
    _Parser_toTypes: function(universe, environment, items) {
      var i,
        $length = H._Utils_arrayLength(items);
      for (i = 0; i < $length; ++i)
        H._Utils_arraySetAt(items, i, H._Parser_toType(universe, environment, H._Utils_arrayAt(items, i)));
    },
    _Parser_toTypesNamed: function(universe, environment, items) {
      var i,
        $length = H._Utils_arrayLength(items);
      H.assertHelper(H._Utils_isMultipleOf($length, 3));
      for (i = 2; i < $length; i += 3)
        H._Utils_arraySetAt(items, i, H._Parser_toType(universe, environment, H._Utils_arrayAt(items, i)));
    },
    _Parser_indexToType: function(universe, environment, index) {
      var typeArguments, len,
        kind = H.Rti__getKind(environment);
      if (kind === 10) {
        if (index === 0)
          return H.Rti__getBindingBase(environment);
        typeArguments = H.Rti__getBindingArguments(environment);
        len = H._Utils_arrayLength(typeArguments);
        if (index <= len)
          return H._Utils_asRti(H._Utils_arrayAt(typeArguments, index - 1));
        index -= len;
        environment = H.Rti__getBindingBase(environment);
        kind = H.Rti__getKind(environment);
      } else if (index === 0)
        return environment;
      if (kind !== 9)
        throw H.wrapException(P.AssertionError$("Indexed base must be an interface type"));
      typeArguments = H.Rti__getInterfaceTypeArguments(environment);
      if (index <= H._Utils_arrayLength(typeArguments))
        return H._Utils_asRti(H._Utils_arrayAt(typeArguments, index - 1));
      throw H.wrapException(P.AssertionError$("Bad index " + index + " for " + environment.toString$0(0)));
    },
    _Parser_toGenericFunctionParameter: function(universe, item) {
      H.assertHelper(H._Utils_isNum(item));
      return H._Universe__lookupGenericFunctionParameterRti(universe, H._Utils_asInt(item));
    },
    TypeRule_lookupTypeVariable: function(rule, typeVariable) {
      return rule[typeVariable];
    },
    TypeRule_lookupSupertype: function(rule, supertype) {
      return rule[supertype];
    },
    isSubtype: function(universe, s, t) {
      return H._isSubtype(universe, s, null, t, null);
    },
    _isSubtype: function(universe, s, sEnv, t, tEnv) {
      var sKind, leftTypeVariable, tKind, t1, sBounds, tBounds, sLength, i, sBound, tBound;
      if (H._Utils_isIdentical(s, t))
        return true;
      if (H.isTopType(t))
        return true;
      sKind = H.Rti__getKind(s);
      if (sKind === 4)
        return true;
      if (H.isStrongTopType(s))
        return false;
      if (H.isBottomType(s))
        return true;
      leftTypeVariable = sKind === 13;
      if (leftTypeVariable)
        if (H._isSubtype(universe, H._Utils_asRti(H._Utils_arrayAt(sEnv, H.Rti__getGenericFunctionParameterIndex(s))), sEnv, t, tEnv))
          return true;
      tKind = H.Rti__getKind(t);
      t1 = H.isNullType(s);
      if (t1) {
        if (tKind === 8)
          return H._isSubtype(universe, s, sEnv, H.Rti__getFutureOrArgument(t), tEnv);
        return H.isNullType(t) || tKind === 7 || tKind === 6;
      }
      t1 = H.isObjectType(t);
      if (t1) {
        if (sKind === 8)
          return H._isSubtype(universe, H.Rti__getFutureOrArgument(s), sEnv, t, tEnv);
        if (sKind === 6)
          return H._isSubtype(universe, H.Rti__getStarArgument(s), sEnv, t, tEnv);
        return sKind !== 7;
      }
      if (sKind === 6)
        return H._isSubtype(universe, H.Rti__getStarArgument(s), sEnv, t, tEnv);
      if (tKind === 6) {
        t1 = H.Rti__getQuestionFromStar(universe, t);
        return H._isSubtype(universe, s, sEnv, t1, tEnv);
      }
      if (sKind === 8) {
        if (!H._isSubtype(universe, H.Rti__getFutureOrArgument(s), sEnv, t, tEnv))
          return false;
        return H._isSubtype(universe, H.Rti__getFutureFromFutureOr(universe, s), sEnv, t, tEnv);
      }
      if (sKind === 7) {
        t1 = H._isSubtype(universe, type$.Null, sEnv, t, tEnv);
        return t1 && H._isSubtype(universe, H.Rti__getQuestionArgument(s), sEnv, t, tEnv);
      }
      if (tKind === 8) {
        if (H._isSubtype(universe, s, sEnv, H.Rti__getFutureOrArgument(t), tEnv))
          return true;
        return H._isSubtype(universe, s, sEnv, H.Rti__getFutureFromFutureOr(universe, t), tEnv);
      }
      if (tKind === 7) {
        t1 = H._isSubtype(universe, s, sEnv, type$.Null, tEnv);
        return t1 || H._isSubtype(universe, s, sEnv, H.Rti__getQuestionArgument(t), tEnv);
      }
      if (leftTypeVariable)
        return false;
      t1 = sKind !== 11;
      if ((!t1 || sKind === 12) && H.isFunctionType(t))
        return true;
      if (tKind === 12) {
        if (H.isJsFunctionType(s))
          return true;
        if (sKind !== 12)
          return false;
        sBounds = H.Rti__getGenericFunctionBounds(s);
        tBounds = H.Rti__getGenericFunctionBounds(t);
        sLength = H._Utils_arrayLength(sBounds);
        if (sLength !== H._Utils_arrayLength(tBounds))
          return false;
        sEnv = sEnv == null ? sBounds : H._Utils_arrayConcat(sBounds, sEnv);
        tEnv = tEnv == null ? tBounds : H._Utils_arrayConcat(tBounds, tEnv);
        for (i = 0; i < sLength; ++i) {
          sBound = H._Utils_asRti(H._Utils_arrayAt(sBounds, i));
          tBound = H._Utils_asRti(H._Utils_arrayAt(tBounds, i));
          if (!H._isSubtype(universe, sBound, sEnv, tBound, tEnv) || !H._isSubtype(universe, tBound, tEnv, sBound, sEnv))
            return false;
        }
        return H._isFunctionSubtype(universe, H.Rti__getGenericFunctionBase(s), sEnv, H.Rti__getGenericFunctionBase(t), tEnv);
      }
      if (tKind === 11) {
        if (H.isJsFunctionType(s))
          return true;
        if (t1)
          return false;
        return H._isFunctionSubtype(universe, s, sEnv, t, tEnv);
      }
      if (sKind === 9) {
        if (tKind !== 9)
          return false;
        return H._isInterfaceSubtype(universe, s, sEnv, t, tEnv);
      }
      return false;
    },
    _isFunctionSubtype: function(universe, s, sEnv, t, tEnv) {
      var sParameters, tParameters, sRequiredPositional, tRequiredPositional, sRequiredPositionalLength, tRequiredPositionalLength, requiredPositionalDelta, sOptionalPositional, tOptionalPositional, sOptionalPositionalLength, tOptionalPositionalLength, i, sParameter, sNamed, tNamed, sNamedLength, tNamedLength, sIndex, tIndex, tName, sName, sIsRequired, tIsRequired, sType;
      H.assertHelper(H.Rti__getKind(s) === 11);
      H.assertHelper(H.Rti__getKind(t) === 11);
      if (!H._isSubtype(universe, H.Rti__getReturnType(s), sEnv, H.Rti__getReturnType(t), tEnv))
        return false;
      sParameters = H.Rti__getFunctionParameters(s);
      tParameters = H.Rti__getFunctionParameters(t);
      sRequiredPositional = H._FunctionParameters__getRequiredPositional(sParameters);
      tRequiredPositional = H._FunctionParameters__getRequiredPositional(tParameters);
      sRequiredPositionalLength = H._Utils_arrayLength(sRequiredPositional);
      tRequiredPositionalLength = H._Utils_arrayLength(tRequiredPositional);
      if (sRequiredPositionalLength > tRequiredPositionalLength)
        return false;
      requiredPositionalDelta = tRequiredPositionalLength - sRequiredPositionalLength;
      sOptionalPositional = H._FunctionParameters__getOptionalPositional(sParameters);
      tOptionalPositional = H._FunctionParameters__getOptionalPositional(tParameters);
      sOptionalPositionalLength = H._Utils_arrayLength(sOptionalPositional);
      tOptionalPositionalLength = H._Utils_arrayLength(tOptionalPositional);
      if (sRequiredPositionalLength + sOptionalPositionalLength < tRequiredPositionalLength + tOptionalPositionalLength)
        return false;
      for (i = 0; i < sRequiredPositionalLength; ++i) {
        sParameter = H._Utils_asRti(H._Utils_arrayAt(sRequiredPositional, i));
        if (!H._isSubtype(universe, H._Utils_asRti(H._Utils_arrayAt(tRequiredPositional, i)), tEnv, sParameter, sEnv))
          return false;
      }
      for (i = 0; i < requiredPositionalDelta; ++i) {
        sParameter = H._Utils_asRti(H._Utils_arrayAt(sOptionalPositional, i));
        if (!H._isSubtype(universe, H._Utils_asRti(H._Utils_arrayAt(tRequiredPositional, sRequiredPositionalLength + i)), tEnv, sParameter, sEnv))
          return false;
      }
      for (i = 0; i < tOptionalPositionalLength; ++i) {
        sParameter = H._Utils_asRti(H._Utils_arrayAt(sOptionalPositional, requiredPositionalDelta + i));
        if (!H._isSubtype(universe, H._Utils_asRti(H._Utils_arrayAt(tOptionalPositional, i)), tEnv, sParameter, sEnv))
          return false;
      }
      sNamed = H._FunctionParameters__getNamed(sParameters);
      tNamed = H._FunctionParameters__getNamed(tParameters);
      sNamedLength = H._Utils_arrayLength(sNamed);
      tNamedLength = H._Utils_arrayLength(tNamed);
      for (sIndex = 0, tIndex = 0; tIndex < tNamedLength; tIndex += 3) {
        tName = H._Utils_asString(H._Utils_arrayAt(tNamed, tIndex));
        for (; true;) {
          if (sIndex >= sNamedLength)
            return false;
          sName = H._Utils_asString(H._Utils_arrayAt(sNamed, sIndex));
          sIndex += 3;
          if (H._Utils_stringLessThan(tName, sName))
            return false;
          sIsRequired = H._Utils_asBool(H._Utils_arrayAt(sNamed, sIndex - 2));
          if (H._Utils_stringLessThan(sName, tName)) {
            if (sIsRequired)
              return false;
            continue;
          }
          tIsRequired = H._Utils_asBool(H._Utils_arrayAt(tNamed, tIndex + 1));
          if (sIsRequired && !tIsRequired)
            return false;
          sType = H._Utils_asRti(H._Utils_arrayAt(sNamed, sIndex - 1));
          if (!H._isSubtype(universe, H._Utils_asRti(H._Utils_arrayAt(tNamed, tIndex + 2)), tEnv, sType, sEnv))
            return false;
          break;
        }
      }
      for (; sIndex < sNamedLength;) {
        if (H._Utils_asBool(H._Utils_arrayAt(sNamed, sIndex + 1)))
          return false;
        sIndex += 3;
      }
      return true;
    },
    _isInterfaceSubtype: function(universe, s, sEnv, t, tEnv) {
      var sArgs, tArgs, $length, i, sArg, tArg, rule, supertypeArgs,
        sName = H.Rti__getInterfaceName(s),
        tName = H.Rti__getInterfaceName(t);
      if (sName === tName) {
        sArgs = H.Rti__getInterfaceTypeArguments(s);
        tArgs = H.Rti__getInterfaceTypeArguments(t);
        $length = H._Utils_arrayLength(sArgs);
        H.assertHelper($length === H._Utils_arrayLength(tArgs));
        for (i = 0; i < $length; ++i) {
          sArg = H._Utils_asRti(H._Utils_arrayAt(sArgs, i));
          tArg = H._Utils_asRti(H._Utils_arrayAt(tArgs, i));
          if (!H._isSubtype(universe, sArg, sEnv, tArg, tEnv))
            return false;
        }
        return true;
      }
      if (H.isObjectType(t))
        return true;
      rule = H._Universe_findRule(universe, sName);
      if (rule == null)
        return false;
      supertypeArgs = H.TypeRule_lookupSupertype(rule, tName);
      if (supertypeArgs == null)
        return false;
      $length = H._Utils_arrayLength(supertypeArgs);
      tArgs = H.Rti__getInterfaceTypeArguments(t);
      H.assertHelper($length === H._Utils_arrayLength(tArgs));
      for (i = 0; i < $length; ++i)
        if (!H._isSubtype(universe, H._Universe_evalInEnvironment(universe, s, H._Utils_asString(H._Utils_arrayAt(supertypeArgs, i))), sEnv, H._Utils_asRti(H._Utils_arrayAt(tArgs, i)), tEnv))
          return false;
      return true;
    },
    isNullable: function(t) {
      var t1,
        kind = H.Rti__getKind(t);
      if (!H.isNullType(t))
        if (!H.isStrongTopType(t))
          if (kind !== 7)
            if (!(kind === 6 && H.isNullable(H.Rti__getStarArgument(t))))
              t1 = kind === 8 && H.isNullable(H.Rti__getFutureOrArgument(t));
            else
              t1 = true;
          else
            t1 = true;
        else
          t1 = true;
      else
        t1 = true;
      return t1;
    },
    isTopType: function(t) {
      var t1;
      if (!H.isStrongTopType(t))
        if (!H.isLegacyObjectType(t))
          t1 = false;
        else
          t1 = true;
      else
        t1 = true;
      return t1;
    },
    isStrongTopType: function(t) {
      var kind = H.Rti__getKind(t);
      return kind === 2 || kind === 3 || kind === 4 || kind === 5 || H.isNullableObjectType(t);
    },
    isBottomType: function(t) {
      var t1;
      if (H.Rti__getKind(t) !== 1)
        t1 = false;
      else
        t1 = true;
      return t1;
    },
    isObjectType: function(t) {
      return H._Utils_isIdentical(t, type$.Object);
    },
    isLegacyObjectType: function(t) {
      return H._Utils_isIdentical(t, type$.legacy_Object);
    },
    isNullableObjectType: function(t) {
      return H._Utils_isIdentical(t, type$.nullable_Object);
    },
    isNullType: function(t) {
      return H._Utils_isIdentical(t, type$.Null) || H._Utils_isIdentical(t, type$.JSNull);
    },
    isFunctionType: function(t) {
      return H._Utils_isIdentical(t, type$.Function);
    },
    isJsFunctionType: function(t) {
      return H._Utils_isIdentical(t, type$.JavaScriptFunction);
    },
    _Utils_asBool: function(o) {
      return o;
    },
    _Utils_asDouble: function(o) {
      return o;
    },
    _Utils_asInt: function(o) {
      return o;
    },
    _Utils_asNum: function(o) {
      return o;
    },
    _Utils_asString: function(o) {
      return o;
    },
    _Utils_asRti: function(s) {
      return s;
    },
    _Utils_asRtiOrNull: function(s) {
      return s;
    },
    _Utils_isString: function(o) {
      return typeof o == "string";
    },
    _Utils_isNum: function(o) {
      return typeof o == "number";
    },
    _Utils_instanceOf: function(o, $constructor) {
      return o instanceof $constructor;
    },
    _Utils_isIdentical: function(s, t) {
      return s === t;
    },
    _Utils_isNotIdentical: function(s, t) {
      return s !== t;
    },
    _Utils_isMultipleOf: function(n, d) {
      return n % d === 0;
    },
    _Utils_objectKeys: function(o) {
      return Object.keys(o);
    },
    _Utils_objectAssign: function(o, other) {
      var i, key,
        keys = H._Utils_objectKeys(other),
        $length = H._Utils_arrayLength(keys);
      for (i = 0; i < $length; ++i) {
        key = H._Utils_asString(H._Utils_arrayAt(keys, i));
        o[key] = other[key];
      }
    },
    _Utils_isArray: function(o) {
      return Array.isArray(o);
    },
    _Utils_arrayLength: function(array) {
      return array.length;
    },
    _Utils_arrayAt: function(array, i) {
      return array[i];
    },
    _Utils_arraySetAt: function(array, i, value) {
      array[i] = value;
    },
    _Utils_arraySplice: function(array, position) {
      return array.splice(position);
    },
    _Utils_arrayConcat: function(a1, a2) {
      return a1.concat(a2);
    },
    _Utils_arrayPush: function(array, value) {
      array.push(value);
    },
    _Utils_substring: function(s, start, end) {
      return s.substring(start, end);
    },
    _Utils_stringLessThan: function(s1, s2) {
      return s1 < s2;
    },
    _Utils_mapGet: function(cache, key) {
      return cache.get(key);
    },
    _Utils_mapSet: function(cache, key, value) {
      cache.set(key, value);
    },
    Rti: function Rti(t0, t1) {
      var _ = this;
      _._as = t0;
      _._is = t1;
      _._cachedRuntimeType = _._specializedTestResource = _._precomputed1 = null;
      _._kind = 0;
      _._canonicalRecipe = _._bindCache = _._evalCache = _._rest = _._primary = null;
    },
    _FunctionParameters: function _FunctionParameters() {
      this._named = this._optionalPositional = this._requiredPositional = null;
    },
    _Error: function _Error() {
    },
    _TypeError: function _TypeError(t0) {
      this._message = t0;
    },
    printToConsole: function(line) {
      H.printString(line);
    },
    IterableElementError_noElement: function() {
      return P.StateError$("No element");
    },
    unmangleGlobalNameIfPreservedAnyways: function($name) {
      return H.JsCache_fetch(init.mangledGlobalNames, $name);
    },
    printString: function(string) {
      if (typeof dartPrint == "function") {
        dartPrint(string);
        return;
      }
      if (typeof console == "object" && typeof console.log != "undefined") {
        console.log(string);
        return;
      }
      if (typeof window == "object")
        return;
      if (typeof print == "function") {
        print(string);
        return;
      }
      throw "Unable to print message: " + String(string);
    },
    Recipe_isDigit: function(code) {
      return code >= 48 && code <= 57;
    },
    Recipe_digitValue: function(code) {
      return code - 48;
    },
    Recipe_isIdentifierStart: function(ch) {
      return (((ch | 32) >>> 0) - 97 & 65535) < 26 || ch === 95 || ch === 36;
    }
  },
  J = {
    JSArray_markFixedList: function(list, $T) {
      list.fixed$length = Array;
      return list;
    },
    JSArray_isFixedLength: function(a) {
      return !!a.fixed$length;
    },
    JSArray_isGrowable: function(a) {
      return !J.JSArray_isFixedLength(a);
    },
    ArrayIterator$: function(iterable, $E) {
      return new J.ArrayIterator(iterable, iterable.length, $E._eval$1("ArrayIterator<0>"));
    },
    getInterceptor$: function(receiver) {
      if (typeof receiver == "number") {
        if (Math.floor(receiver) == receiver)
          return J.JSInt.prototype;
        return J.JSDouble.prototype;
      }
      if (typeof receiver == "string")
        return J.JSString.prototype;
      if (receiver == null)
        return J.JSNull.prototype;
      if (typeof receiver == "boolean")
        return J.JSBool.prototype;
      if (receiver.constructor == Array)
        return J.JSArray.prototype;
      return receiver;
    },
    getInterceptor$a: function(receiver) {
      if (receiver == null)
        return receiver;
      if (receiver.constructor == Array)
        return J.JSArray.prototype;
      return receiver;
    },
    getInterceptor$as: function(receiver) {
      if (typeof receiver == "string")
        return J.JSString.prototype;
      if (receiver == null)
        return receiver;
      if (receiver.constructor == Array)
        return J.JSArray.prototype;
      return receiver;
    },
    getInterceptor$ns: function(receiver) {
      if (typeof receiver == "number")
        return J.JSNumber.prototype;
      if (typeof receiver == "string")
        return J.JSString.prototype;
      if (receiver == null)
        return receiver;
      return receiver;
    },
    get$iterator$a: function(receiver) {
      return J.getInterceptor$a(receiver).get$iterator(receiver);
    },
    get$length$as: function(receiver) {
      return J.getInterceptor$as(receiver).get$length(receiver);
    },
    $add$ns: function(receiver, a0) {
      if (typeof receiver == "number" && typeof a0 == "number")
        return receiver + a0;
      return J.getInterceptor$ns(receiver).$add(receiver, a0);
    },
    toString$0$: function(receiver) {
      return J.getInterceptor$(receiver).toString$0(receiver);
    },
    Interceptor: function Interceptor() {
    },
    JSBool: function JSBool() {
    },
    JSNull: function JSNull() {
    },
    JSArray: function JSArray(t0) {
      this.$ti = t0;
    },
    JSUnmodifiableArray: function JSUnmodifiableArray(t0) {
      this.$ti = t0;
    },
    ArrayIterator: function ArrayIterator(t0, t1, t2) {
      var _ = this;
      _._iterable = t0;
      _._length = t1;
      _._index = 0;
      _._current = null;
      _.$ti = t2;
    },
    JSNumber: function JSNumber() {
    },
    JSInt: function JSInt() {
    },
    JSDouble: function JSDouble() {
    },
    JSString: function JSString() {
    }
  },
  P = {
    LinkedHashSet_LinkedHashSet$_empty: function($E) {
      return P._LinkedHashSet$($E);
    },
    _LinkedHashSet$: function($E) {
      return new P._LinkedHashSet($E._eval$1("_LinkedHashSet<0>"));
    },
    _LinkedHashSetIterator$: function(_set, _modifications, $E) {
      var t1 = new P._LinkedHashSetIterator(_set, _modifications, $E._eval$1("_LinkedHashSetIterator<0>"));
      t1._LinkedHashSetIterator$2(_set, _modifications, $E);
      return t1;
    },
    IterableBase_iterableToFullString: function(iterable, leftDelimiter, rightDelimiter) {
      var buffer;
      if (P._isToStringVisiting(iterable))
        return leftDelimiter + "..." + rightDelimiter;
      buffer = P.StringBuffer$(leftDelimiter);
      C.JSArray_methods.add$1($._toStringVisiting, iterable);
      try {
        buffer.writeAll$2(iterable, ", ");
      } finally {
        H.assertHelper(C.JSArray_methods.get$last($._toStringVisiting) === iterable);
        if (0 >= $._toStringVisiting.length)
          return H.ioore($._toStringVisiting, -1);
        $._toStringVisiting.pop();
      }
      buffer.write$1(rightDelimiter);
      return J.toString$0$(buffer);
    },
    _isToStringVisiting: function(o) {
      var t1, i;
      for (t1 = $._toStringVisiting.length, i = 0; i < t1; ++i)
        if (o === $._toStringVisiting[i])
          return true;
      return false;
    },
    ListBase_listToString: function(list) {
      return P.IterableBase_iterableToFullString(list, "[", "]");
    },
    _LinkedHashSet: function _LinkedHashSet(t0) {
      var _ = this;
      _._collection$_length = 0;
      _._last = _._first = _._collection$_rest = _._nums = _._strings = null;
      _._modifications = 0;
      _.$ti = t0;
    },
    _LinkedHashSetIterator: function _LinkedHashSetIterator(t0, t1, t2) {
      var _ = this;
      _._set = t0;
      _._modifications = t1;
      _._collection$_current = _._cell = null;
      _.$ti = t2;
    },
    _SetBase: function _SetBase() {
    },
    Error__objectToString: function(object) {
      if (object instanceof H.Closure)
        return object.toString$0(0);
      return H.Primitives_objectToHumanReadableString(object);
    },
    Error__stringToSafeString: function(string) {
      return H.jsonEncodeNative(string);
    },
    StringBuffer$: function($content) {
      return new P.StringBuffer($content);
    },
    StringBuffer__writeAll: function(string, objects, separator) {
      var iterator = J.get$iterator$a(objects);
      if (!iterator.moveNext$0())
        return string;
      if (C.JSString_methods.get$isEmpty(separator)) {
        do
          string = P.StringBuffer__writeOne(string, iterator.get$current());
        while (iterator.moveNext$0());
      } else {
        string = P.StringBuffer__writeOne(string, iterator.get$current());
        for (; iterator.moveNext$0();)
          string = P.StringBuffer__writeOne(P.StringBuffer__writeOne(string, separator), iterator.get$current());
      }
      return string;
    },
    StringBuffer__writeOne: function(string, obj) {
      return H.Primitives_stringConcatUnchecked(string, H.S(obj));
    },
    Error_safeToString: function(object) {
      if (typeof object == "number" || H._isBool(object) || null == object)
        return J.toString$0$(object);
      if (typeof object == "string")
        return P.Error__stringToSafeString(object);
      return P.Error__objectToString(object);
    },
    AssertionError$: function(message) {
      return new P.AssertionError(message);
    },
    NullThrownError$: function() {
      return new P.NullThrownError();
    },
    ArgumentError$: function(message) {
      return new P.ArgumentError(false, null, null, message);
    },
    ArgumentError$value: function(value, $name, message) {
      return new P.ArgumentError(true, value, $name, message);
    },
    RangeError$value: function(value, $name) {
      return new P.RangeError(true, value, $name, "Value not in range");
    },
    IndexError$: function(invalidValue, indexable, $name, message, $length) {
      return new P.IndexError($length, true, invalidValue, $name, "Index out of range");
    },
    UnsupportedError$: function(message) {
      return new P.UnsupportedError(message);
    },
    StateError$: function(message) {
      return new P.StateError(message);
    },
    ConcurrentModificationError$: function(modifiedObject) {
      return new P.ConcurrentModificationError(modifiedObject);
    },
    CyclicInitializationError$: function(variableName) {
      return new P.CyclicInitializationError(variableName);
    },
    print: function(object) {
      H.printToConsole(J.toString$0$(object));
    },
    bool: function bool() {
    },
    double: function double() {
    },
    Error: function Error() {
    },
    AssertionError: function AssertionError(t0) {
      this.message = t0;
    },
    NullThrownError: function NullThrownError() {
    },
    ArgumentError: function ArgumentError(t0, t1, t2, t3) {
      var _ = this;
      _._hasValue = t0;
      _.invalidValue = t1;
      _.name = t2;
      _.message = t3;
    },
    RangeError: function RangeError(t0, t1, t2, t3) {
      var _ = this;
      _._hasValue = t0;
      _.invalidValue = t1;
      _.name = t2;
      _.message = t3;
    },
    IndexError: function IndexError(t0, t1, t2, t3, t4) {
      var _ = this;
      _.length = t0;
      _._hasValue = t1;
      _.invalidValue = t2;
      _.name = t3;
      _.message = t4;
    },
    UnsupportedError: function UnsupportedError(t0) {
      this.message = t0;
    },
    StateError: function StateError(t0) {
      this.message = t0;
    },
    ConcurrentModificationError: function ConcurrentModificationError(t0) {
      this.modifiedObject = t0;
    },
    CyclicInitializationError: function CyclicInitializationError(t0) {
      this.variableName = t0;
    },
    int: function int() {
    },
    List: function List() {
    },
    Null: function Null() {
    },
    num: function num() {
    },
    Object: function Object() {
    },
    String: function String() {
    },
    StringBuffer: function StringBuffer(t0) {
      this._contents = t0;
    }
  },
  K = {
    Base$: function($name) {
      var t1 = new K.Base(P.LinkedHashSet_LinkedHashSet$_empty(type$.String), $name);
      t1.Base$1($name);
      return t1;
    },
    Extends$: function($name) {
      var t1 = $.globalA,
        t2 = "extends " + $name;
      t1 = new K.Extends(t1, P.LinkedHashSet_LinkedHashSet$_empty(type$.String), t2);
      t1.Base$1(t2);
      t1.Extends$1($name);
      return t1;
    },
    main: function() {
      P.print(K.Base$("Freddie"));
      P.print(K.Extends$("Ella"));
      P.print(K.Extends$("June").count++);
      $.globalA = !$.globalA;
      P.print(K.Extends$("June").fieldA);
    },
    Base: function Base(t0, t1) {
      this.count = 0;
      this.colours = t0;
      this.name = t1;
    },
    Extends: function Extends(t0, t1, t2) {
      var _ = this;
      _.fieldA = t0;
      _.count = 0;
      _.colours = t1;
      _.name = t2;
    }
  };
  var holders = [C, H, J, P, K];
  hunkHelpers.setFunctionNamesIfNecessary(holders);
  var $ = {};
  H.JS_CONST.prototype = {};
  J.Interceptor.prototype = {
    toString$0: function(receiver) {
      return H.Primitives_objectToHumanReadableString(receiver);
    }
  };
  J.JSBool.prototype = {
    toString$0: function(receiver) {
      return String(receiver);
    },
    $isbool: 1
  };
  J.JSNull.prototype = {
    toString$0: function(receiver) {
      return "null";
    }
  };
  J.JSArray.prototype = {
    checkGrowable$1: function(receiver, reason) {
      if (!J.JSArray_isGrowable(receiver))
        throw H.wrapException(P.UnsupportedError$(reason));
    },
    add$1: function(receiver, value) {
      H._arrayInstanceType(receiver)._precomputed1._as(value);
      this.checkGrowable$1(receiver, "add");
      receiver.push(value);
    },
    get$last: function(receiver) {
      var t1 = receiver.length;
      if (t1 > 0)
        return receiver[t1 - 1];
      throw H.wrapException(H.IterableElementError_noElement());
    },
    toString$0: function(receiver) {
      return P.ListBase_listToString(receiver);
    },
    get$iterator: function(receiver) {
      return J.ArrayIterator$(receiver, H._arrayInstanceType(receiver)._precomputed1);
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    $isIterable: 1
  };
  J.JSUnmodifiableArray.prototype = {};
  J.ArrayIterator.prototype = {
    get$current: function() {
      return this.$ti._precomputed1._as(this._current);
    },
    moveNext$0: function() {
      var t2, _this = this,
        t1 = _this._iterable,
        $length = t1.length;
      if (_this._length !== $length)
        throw H.wrapException(H.throwConcurrentModificationError(t1));
      t2 = _this._index;
      if (t2 >= $length) {
        _this.set$_current(null);
        return false;
      }
      _this.set$_current(t1[t2]);
      ++_this._index;
      return true;
    },
    set$_current: function(_current) {
      this._current = this.$ti._eval$1("1?")._as(_current);
    }
  };
  J.JSNumber.prototype = {
    toString$0: function(receiver) {
      if (receiver === 0 && 1 / receiver < 0)
        return "-0.0";
      else
        return "" + receiver;
    }
  };
  J.JSInt.prototype = {$isint: 1};
  J.JSDouble.prototype = {};
  J.JSString.prototype = {
    $add: function(receiver, other) {
      H._asString(other);
      return receiver + other;
    },
    get$isEmpty: function(receiver) {
      return receiver.length === 0;
    },
    toString$0: function(receiver) {
      return receiver;
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    $isString: 1
  };
  H.Closure.prototype = {
    toString$0: function(_) {
      var $constructor = this.constructor,
        $name = $constructor == null ? null : $constructor.name;
      return "Closure '" + H.unminifyOrTag($name == null ? "unknown" : $name) + "'";
    },
    get$$call: function() {
      return this;
    },
    "call*": "call$1",
    $requiredArgCount: 1,
    $defaultValues: null
  };
  H.TearOffClosure.prototype = {};
  H.StaticClosure.prototype = {
    toString$0: function(_) {
      var $name = this.$static_name;
      if ($name == null)
        return "Closure of unknown static method";
      return "Closure '" + H.unminifyOrTag($name) + "'";
    }
  };
  H.BoundClosure.prototype = {
    toString$0: function(_) {
      var receiver = this._receiver;
      if (receiver == null)
        receiver = this._self;
      return "Closure '" + H.S(this._name) + "' of " + H.Primitives_objectToHumanReadableString(type$.Object._as(receiver));
    }
  };
  H.RuntimeError.prototype = {
    toString$0: function(_) {
      return "RuntimeError: " + this.message;
    }
  };
  H._AssertionError.prototype = {
    toString$0: function(_) {
      return "Assertion failed: " + P.Error_safeToString(this.message);
    }
  };
  H.Rti.prototype = {
    _eval$1: function(recipe) {
      return H._rtiEval(this, H._Utils_asString(recipe));
    },
    _bind$1: function(typeOrTuple) {
      return H._rtiBind(this, H._Utils_asRti(typeOrTuple));
    }
  };
  H._FunctionParameters.prototype = {};
  H._Error.prototype = {
    toString$0: function(_) {
      return this._message;
    }
  };
  H._TypeError.prototype = {};
  P._LinkedHashSet.prototype = {
    get$iterator: function(_) {
      return P._LinkedHashSetIterator$(this, this._modifications, this.$ti._precomputed1);
    },
    get$length: function(_) {
      return this._collection$_length;
    },
    get$isEmpty: function(_) {
      return this._collection$_length === 0;
    }
  };
  P._LinkedHashSetIterator.prototype = {
    _LinkedHashSetIterator$2: function(_set, _modifications, $E) {
      this._cell = this._set._first;
    },
    get$current: function() {
      return this.$ti._precomputed1._as(this._collection$_current);
    },
    moveNext$0: function() {
      var _this = this,
        cell = _this._cell,
        t1 = _this._set;
      if (_this._modifications !== t1._modifications)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      else if (cell == null) {
        _this.set$_collection$_current(null);
        return false;
      } else {
        _this.set$_collection$_current(_this.$ti._eval$1("1?")._as(cell._element));
        _this._cell = cell._next;
        return true;
      }
    },
    set$_collection$_current: function(_current) {
      this._collection$_current = this.$ti._eval$1("1?")._as(_current);
    }
  };
  P._SetBase.prototype = {
    toString$0: function(_) {
      return P.IterableBase_iterableToFullString(this, "{", "}");
    },
    $isIterable: 1,
    $isSet: 1
  };
  P.bool.prototype = {
    toString$0: function(_) {
      return this ? "true" : "false";
    }
  };
  P.double.prototype = {};
  P.Error.prototype = {};
  P.AssertionError.prototype = {
    toString$0: function(_) {
      var t1 = this.message;
      if (t1 != null)
        return "Assertion failed: " + P.Error_safeToString(t1);
      return "Assertion failed";
    }
  };
  P.NullThrownError.prototype = {
    toString$0: function(_) {
      return "Throw of null.";
    }
  };
  P.ArgumentError.prototype = {
    get$_errorName: function() {
      return "Invalid argument" + (!this._hasValue ? "(s)" : "");
    },
    get$_errorExplanation: function() {
      return "";
    },
    toString$0: function(_) {
      var explanation, errorValue, _this = this,
        $name = _this.name,
        nameString = $name == null ? "" : " (" + $name + ")",
        message = _this.message,
        messageString = message == null ? "" : ": " + message,
        prefix = _this.get$_errorName() + nameString + messageString;
      if (!_this._hasValue)
        return prefix;
      explanation = _this.get$_errorExplanation();
      errorValue = P.Error_safeToString(_this.invalidValue);
      return prefix + explanation + ": " + errorValue;
    }
  };
  P.RangeError.prototype = {
    get$_errorName: function() {
      return "RangeError";
    },
    get$_errorExplanation: function() {
      H.assertHelper(this._hasValue);
      return "";
    }
  };
  P.IndexError.prototype = {
    get$_errorName: function() {
      return "RangeError";
    },
    get$_errorExplanation: function() {
      H.assertHelper(this._hasValue);
      if (H._asInt(this.invalidValue) < 0)
        return ": index must not be negative";
      var t1 = this.length;
      if (t1 === 0)
        return ": no indices are valid";
      return ": index should be less than " + t1;
    },
    get$length: function(receiver) {
      return this.length;
    }
  };
  P.UnsupportedError.prototype = {
    toString$0: function(_) {
      return "Unsupported operation: " + this.message;
    }
  };
  P.StateError.prototype = {
    toString$0: function(_) {
      return "Bad state: " + this.message;
    }
  };
  P.ConcurrentModificationError.prototype = {
    toString$0: function(_) {
      return "Concurrent modification during iteration: " + P.Error_safeToString(this.modifiedObject) + ".";
    }
  };
  P.CyclicInitializationError.prototype = {
    toString$0: function(_) {
      var variableName = this.variableName;
      return variableName == null ? "Reading static variable during its initialization" : "Reading static variable '" + variableName + "' during its initialization";
    }
  };
  P.int.prototype = {};
  P.List.prototype = {$isIterable: 1};
  P.Null.prototype = {
    toString$0: function(_) {
      return "null";
    }
  };
  P.num.prototype = {};
  P.Object.prototype = {constructor: P.Object, $isObject: 1,
    toString$0: function(_) {
      return H.Primitives_objectToHumanReadableString(this);
    },
    toString: function() {
      return this.toString$0(this);
    }
  };
  P.String.prototype = {};
  P.StringBuffer.prototype = {
    get$length: function(_) {
      return this._contents.length;
    },
    write$1: function(obj) {
      this._writeString$1(obj);
    },
    writeAll$2: function(objects, separator) {
      this._contents = P.StringBuffer__writeAll(this._contents, objects, separator);
    },
    toString$0: function(_) {
      return H.Primitives_flattenString(this._contents);
    },
    _writeString$1: function(str) {
      this._contents = H.Primitives_stringConcatUnchecked(this._contents, str);
    }
  };
  K.Base.prototype = {
    Base$1: function($name) {
      H.assertHelper(this.name !== "");
    }
  };
  K.Extends.prototype = {
    Extends$1: function($name) {
      var t1 = this.colours;
      H.assertHelper(t1.get$isEmpty(t1));
      H.assertHelper($name !== this.name);
    }
  };
  (function inheritance() {
    var _inherit = hunkHelpers.inherit,
      _inheritMany = hunkHelpers.inheritMany;
    _inherit(P.Object, null);
    _inheritMany(P.Object, [H.JS_CONST, J.Interceptor, J.ArrayIterator, H.Closure, P.Error, H.Rti, H._FunctionParameters, P._SetBase, P._LinkedHashSetIterator, P.bool, P.num, P.List, P.Null, P.String, P.StringBuffer, K.Base]);
    _inheritMany(J.Interceptor, [J.JSBool, J.JSNull, J.JSArray, J.JSNumber, J.JSString]);
    _inherit(J.JSUnmodifiableArray, J.JSArray);
    _inheritMany(J.JSNumber, [J.JSInt, J.JSDouble]);
    _inherit(H.TearOffClosure, H.Closure);
    _inheritMany(H.TearOffClosure, [H.StaticClosure, H.BoundClosure]);
    _inheritMany(P.Error, [H.RuntimeError, P.AssertionError, H._Error, P.NullThrownError, P.ArgumentError, P.UnsupportedError, P.StateError, P.ConcurrentModificationError, P.CyclicInitializationError]);
    _inherit(H._AssertionError, P.AssertionError);
    _inherit(H._TypeError, H._Error);
    _inherit(P._LinkedHashSet, P._SetBase);
    _inheritMany(P.num, [P.double, P.int]);
    _inheritMany(P.ArgumentError, [P.RangeError, P.IndexError]);
    _inherit(K.Extends, K.Base);
  })();
  var init = {
    typeUniverse: {eC: new Map(), tR: {}, eT: {}, tPV: {}, sEA: []},
    mangledGlobalNames: {int: "int", double: "double", num: "num", String: "String", bool: "bool", Null: "Null", List: "List"},
    mangledNames: {},
    getTypeFromName: getGlobalFromName,
    metadata: [],
    types: [],
    arrayRti: typeof Symbol == "function" && typeof Symbol() == "symbol" ? Symbol("$ti") : "$ti"
  };
  H._Universe_addRules(init.typeUniverse, JSON.parse('{"JSBool":{"bool":[]},"JSArray":{"Iterable":["1"]},"JSUnmodifiableArray":{"JSArray":["1"],"Iterable":["1"]},"JSInt":{"int":[]},"JSString":{"String":[]},"_LinkedHashSet":{"Set":["1"],"Iterable":["1"]},"_SetBase":{"Set":["1"],"Iterable":["1"]},"List":{"Iterable":["1"]}}'));
  H._Universe_addErasedTypes(init.typeUniverse, JSON.parse('{"_SetBase":1}'));
  0;
  var type$ = (function rtii() {
    var findType = H.findType;
    return {
      Function: findType("Function"),
      JSArray_String: findType("JSArray<String>"),
      JSArray_dynamic: findType("JSArray<@>"),
      JSNull: findType("JSNull"),
      JavaScriptFunction: findType("JavaScriptFunction"),
      Null: findType("Null"),
      Object: findType("Object"),
      String: findType("String"),
      bool: findType("bool"),
      double: findType("double"),
      dynamic: findType("@"),
      int: findType("int"),
      legacy_Never: findType("0&*"),
      legacy_Object: findType("Object*"),
      nullable_Future_Null: findType("Future<Null>?"),
      nullable_Object: findType("Object?"),
      num: findType("num")
    };
  })();
  (function constants() {
    C.Interceptor_methods = J.Interceptor.prototype;
    C.JSArray_methods = J.JSArray.prototype;
    C.JSString_methods = J.JSString.prototype;
    C.C_JS_CONST = function getTagFallback(o) {
  var s = Object.prototype.toString.call(o);
  return s.substring(8, s.length - 1);
};
  })();
  (function staticFields() {
    $.Closure_functionCounter = 0;
    $.BoundClosure_selfFieldNameCache = null;
    $.BoundClosure_receiverFieldNameCache = null;
    $._toStringVisiting = H.setRuntimeTypeInfo([], H.findType("JSArray<Object>"));
    $.globalA = true;
  })();
  (function nativeSupport() {
    hunkHelpers.setOrUpdateInterceptorsByTag({});
    hunkHelpers.setOrUpdateLeafTags({});
  })();
  convertAllToFastObject(holders);
  convertToFastObject($);
  (function(callback) {
    if (typeof document === "undefined") {
      callback(null);
      return;
    }
    if (typeof document.currentScript != 'undefined') {
      callback(document.currentScript);
      return;
    }
    var scripts = document.scripts;
    function onLoad(event) {
      for (var i = 0; i < scripts.length; ++i)
        scripts[i].removeEventListener("load", onLoad, false);
      callback(event.target);
    }
    for (var i = 0; i < scripts.length; ++i)
      scripts[i].addEventListener("load", onLoad, false);
  })(function(currentScript) {
    init.currentScript = currentScript;
    if (typeof dartMainRunner === "function")
      dartMainRunner(K.main, []);
    else
      K.main([]);
  });
})();

//# sourceMappingURL=classes1.dart.dart2js.js.map
