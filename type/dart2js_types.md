# Reified types in dart2js

--------------------------------------------------------------------------------

Types in dart2js are implemented largely by a library,
[js_runtime/lib/rti.dart](https://github.com/dart-lang/sdk/blob/master/sdk/lib/_internal/js_runtime/lib/rti.dart).

One of the design principles was to do as much as possible in one operation, and
to cache results so that runtime operations are mostly a fast access via a cache.
All types, and some other things, are represented through one class, `Rti`.
`Rti` objects are _interned_, so there is only one `Rti` object representing any type, no matter how it is constructed.
This means that a cache on the type can be reused across contexts.

## Rti structure

The core structure of an `Rti` is essentially a tagged union. Each `Rti` object has a small integer tag denoting the kind of type it represents - interface type, function type, nullable type, etc. - as well as some additional data fields which are populated depending on the tag. For example, if we have an interface type `Rti`, the primary data is the `String` containing the class name, and the additional data is the list of `Rti`s representing the type arguments. If we have a legacy type `T*`, the primary data is the `Rti` representing `T` and there is no additional data.

Each `Rti` also contains its recipe (see below). These recipes use some shorthand but are human-readable overall, so they can be a good way to quickly read an `Rti` when debugging.

## Type tests

`Rti` objects have two fields `_is` and `_as`.
These contain JavaScript functions that perform the 'is' and 'as' Dart operations.

    x is T   -->   T._is(x)
    a as Z   -->   Z._as(a)

`_is` and `_as` are fields of a small object so the field names minify to single letter names which makes this code pattern quite compact.

## Ground types

Type expressions are either _ground types_, or _dependent type expressions_ containing free type variables.
Both are generated by interpreting a string representation of the type, which we call a _recipe_.
We were lucky to be able to contrive that the recipe looks rather like a Dart type expression.

Ground types are created via calls to `findType`.

    H.findType("String")               // `String`
    H.findType("String?")              // `String?`
    H.findType("List<Comparable>")     // `List<Comparable>`
    H.findType("JSArray<String>")      // `JSArray<String>`
    H.findType("String?(String)")      // `String? Function(String)`

dart2js arranges that many ground types are available from a top-level variable that has the (unminified) name `type$`.

    var type$ = {
      String: H.findType("String"),
      nullable_String: H.findType("String?"),
      List_String: H.findType("List<String>"),
      ...
    };

So `x is List<String>` usually compiles to `type$.List_String._is(x)`.

The `Rti` objects form a DAG. `String?` is represented as a 'nullable' `Rti` object that references an 'interface-type' `Rti` object:

    +-----+       +--------+
    | '?' | ----> | String |
    +-----+       +--------+


## Types of instances

The Rti library has a method `_instanceType(x)` that returns the `Rti` object for the full type of `x`.

- Instances of generic types store their full type in a property called `$ti`.
- Instances of non-generic types store their full type on the JavaScript constructor.
- Intercepted types are not* generic, so they store their full type on the JavaScript constructor for the interceptor. `NativeInt8List` is not generic, even though it does implement a generic interface.
- Primitive implementation types like `JSString` and `JSInt` are intercepted types. (`String` and `int` are pure interfaces and have no instances.)
- JavaScript Arrays (JSArray) are a special case of intercepted types that store the full type (e.g. `type$.JSArray_String`) on a special symbol property.
- Closures are complicated and described later.

Often we know something about `x`, so we can reduce the general call `_instanceType(x)` to something more efficient.
For example in a method defined on a generic class with no subclasses, `_instanceType(this)` can be replaced by `this.$ti`.


## Derived type expressions

Derived type expressions are expressions that depend on a _type environment_.
The type environment defines the enclosing type variables. These come from the enclosing class and generic methods and functions.

The `Rti._eval` method evaluates a type recipe against a type environment.
The recipe contains variable references, either by name or by position.

    class IterableMixin<E> {
      ...
      T fold<T>(T initialValue, T combine(T previousValue, E element)) {
        // Type environment here defines `IterableMixin.E` and `fold.T`
        var value = initialValue;
        for (E element in this) value = combine(value, element);
        return value;
      }
    }

The type environment is constructed from the root type environment by binding types for the generic.
A type check for `combine` looks like:

      H._instanceType(this)._bind$1($T)._eval$1("1(1,IterableMixin.E)")._as(combine);

`Rti._eval` uses a cache on the `Rti` representing the environment, so after a short while, the `Rti` objects come from the cache.


# Optimizations

## Lazy initialization of tests

The `_is` and `_as` fields can contain specialized methods for performing the checks.
It turns out that most types are not used in `is`- and `as`- checks, so the library defers any decision
by initializing the `_is` and `_as` fields to initializer stubs.
The initializer stub overwrites the `_is`/`_as` field with the real implementation.
When a stub is called, the `Rti` tree is inspected to see if it matches one of the known patterns.
The default for `x is T` is a method that tests if `subtype(_instanceType(x), T)`.

For primitive types it is much more efficient to use a corresponding JavaScript fragment.

    H._isString: function(o) {
      return typeof o == "string";
    },
    H._isInt: function(o) {
      return typeof o == "number" && o == Math.floor(o);
    }

The `_is` initializer stub knows about `_isString` and `_isInt` and uses them instead of the default stub.
This makes the test `x is T` in a generic context much more efficient.

The optimizer also knows about these specializations and will reduce `$types.int._is(x)` to `H._isInt(x)`.
    

## Ground types, eval chains

A ground type followed by eval can be reduced to the constructed ground type.

Back-to-back evals can be reduced to a single eval.
Generally this means there are more entries in the cache on the root environment but fewer cache lookups to get the final `Rti`.

